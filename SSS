if _G.ServerDataLoaded then
    print("‚ö†Ô∏è ServerData already loaded, skipping duplicate initialization")
    return
end
_G.ServerDataLoaded = true

local currentLoopId = 0
local TitleManager = require(game.ServerScriptService.Modules.TitleManager)
local Value = true

-- Services
local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local HttpService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")
local TeleportService = game:GetService("TeleportService")
local MarketplaceService = game:GetService("MarketplaceService")
local RunService = game:GetService("RunService")

-- Data Store
local DataStore = DataStoreService:GetDataStore("Update_PlayerDataRework_SecondSea")
local CrewDataStore = DataStoreService:GetDataStore("CrewData")
local ShopDataStore = DataStoreService:GetDataStore("ShopData")
local AutoSaveInterval = 300 -- 5 minutes

-- Modules
local HitboxService = require(ReplicatedStorage.Modules.Hitbox)
local Net = require(ReplicatedStorage.Modules.Net)
local Effect = require(ReplicatedStorage.Effect)
local TableUtil = require(ReplicatedStorage:WaitForChild("Modules").TableUtil)
local Quests = require(ReplicatedStorage.Quests)
local MaterialRarities = require(ServerScriptService.Rarities.MaterialRarities)
local ItemRarities = require(ServerScriptService.Rarities.ItemRarities)
local AuraSkins = require(ReplicatedStorage.Modules.SkinUtil.AuraSkins)
local FruitSkins = require(ReplicatedStorage.Modules.SkinUtil.FruitSkins)

-- Paths
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local CommF_ = Remotes:WaitForChild("CommF_")
local Style = Remotes:WaitForChild("Style")
local CommE = Remotes:WaitForChild("CommE")
local AccessoryFolder = ServerStorage:WaitForChild("Accessories")
local ContentCreators = {
	"Angel_GodsM",
	"tripulanteuno",
	"Notbloxfruitcopy",
	"PS99ZALTACCPINt",
	"Not_Yashu07",
	"black_nath341",
	"Veeru_Gamer12",
	"ADG_Aaru",
	"CalciumPlayzZz",
	"BloxWithGames",
	"LONGFOR9",
	"HyperJay06_Official",
	"icewizhero",
	"KDDPLA",
}

-- Global Tables
_G.session = {}
_G.WrappedPlayers = {}
local PlayerData = {}
local CrewData = {}
local folder
local SkinUtil = {}
local VFXWrappers = {}
local FeaturedChromaticCache = { Expires = nil, Skin = nil }

-- VFX Attribute Validators
local VFXAttributeTypes = {
	Default = function(name)
		return name:sub(1, 7) == "Default"
	end,
	Shifted = function(name)
		return name:sub(1, 7) == "Shifted"
	end,
	GrayscaleToColorStrength = function(name)
		return name == "GrayscaleToColorStrength"
	end,
	GrayscaleToColorSequence = function(name)
		return name == "GrayscaleToColorSequence"
	end
}

SkinUtil.allowedVFXAttributes = VFXAttributeTypes

-- Apply HSV Color Shift
SkinUtil.applyColorShiftHSV = function(baseColor, hueShift, satMult, valMult)
	local maxComponent = math.max(1, baseColor.R, baseColor.G, baseColor.B)
	local r = math.floor(baseColor.R / maxComponent * 255) % 256
	local g = math.floor(baseColor.G / maxComponent * 255) % 256
	local b = math.floor(baseColor.B / maxComponent * 255) % 256

	local h, s, v = Color3.fromRGB(r, g, b):ToHSV()
	local newH = (h + hueShift) % 1
	local newS = math.clamp(s * satMult, 0, 1)
	local newV = math.clamp(v * valMult, 0, 1)

	return Color3.fromHSV(newH, newS, newV * maxComponent)
end

-- Apply Skin to Rig
local function applySkinToRig(skinData)
	local function recursiveApply(skinTable, rigPart, storagePart)
		for partName, partData in pairs(skinTable) do
			local targetPart = rigPart:FindFirstChild(partName)

			-- Remove existing SurfaceAppearance
			if rigPart:FindFirstChildOfClass("SurfaceAppearance") then
				for _, child in pairs(rigPart:GetChildren()) do
					if child:IsA("SurfaceAppearance") then
						child:Destroy()
					end
				end
			elseif targetPart and targetPart:FindFirstChildOfClass("SurfaceAppearance") then
				for _, child in pairs(targetPart:GetChildren()) do
					if child:IsA("SurfaceAppearance") then
						child:Destroy()
					end
				end
			end

			-- Apply SurfaceAppearance if needed
			
			if partData.Properties and partData.Properties.ClassName == "SurfaceAppearance" then
				local surfaceTemplate = (storagePart:FindFirstChild(skinData.skinName) or storagePart:FindFirstChild("Default")):Clone()
				surfaceTemplate.Name = skinData.skinName
				surfaceTemplate.Parent = rigPart
				targetPart = surfaceTemplate
			end

			-- Apply properties
			if targetPart then
				if partData.Properties then
					for propName, propValue in pairs(partData.Properties) do
						if propName ~= "ClassName" then
							targetPart[propName] = propValue
						end
					end
				end

				-- Recursively apply to children
				if partData.Children then
					recursiveApply(partData.Children, targetPart, storagePart:FindFirstChild(partName))
				end
			else
				warn("No matching part in rig found with name", partName)
			end
		end
	end

	local rigStorage = skinData.modulescript:FindFirstChild("Rig")
	local skinModule = require(skinData.modulescript)[skinData.skinName]

	if not skinModule then
		warn(("No %s skin"):format(skinData.skinName))
		return
	elseif not rigStorage then
		warn(("No %s storage"):format(skinData.skinName))
		return
	end

	recursiveApply(skinModule, skinData.rig, rigStorage)
end

-- Apply Chalice Color
SkinUtil.applyChaliceColor = function(chalice, colorData)
	local outline = chalice:FindFirstChild("Outline")
	if not outline or not outline:IsA("BasePart") then
		print("Outline invalid", outline, typeof(outline), chalice:GetChildren())
		return function() end
	end

	local tween = nil
	if colorData.FadeColor then
		outline.Color = colorData.Color
		tween = TweenService:Create(outline, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, -1, true, 0), {
			Color = colorData.FadeColor
		})
		tween:Play()
	end

	return function()
		if tween then
			tween:Cancel()
			tween = nil
		end
	end
end

-- Apply Skin
SkinUtil.applySkin = function(skinName, rigMappings)
	for rigInstance, skinPath in pairs(rigMappings) do
		assert(typeof(rigInstance) == "Instance")
		assert(typeof(skinPath) == "string")

		local pathParts = skinPath:split(".")
		local moduleScript = script.SkinnedRigs:FindFirstChild(pathParts[1])

		for i = 2, #pathParts do
			moduleScript = moduleScript:FindFirstChild(pathParts[i])
		end

		if not moduleScript then
			warn("No Rig data found for", pathParts)
		else
			applySkinToRig({
				modulescript = moduleScript,
				skinName = skinName,
				rig = rigInstance
			})
		end
	end
end

-- Get Skin from Equipped Fruit
SkinUtil.getSkinFromEquippedFruit = function(player)
	local dataFolder = player:FindFirstChild("Data")
	local devilFruit = dataFolder and dataFolder:FindFirstChild("DevilFruit")

	if dataFolder and devilFruit then
		local fruitSkin = devilFruit:GetAttribute("FruitSkin")
		return {
			FruitNameEquipped = devilFruit.Value,
			Skin = fruitSkin and FruitSkins.Ungrouped[fruitSkin] or nil
		}
	else
		return {}
	end
end

-- Get Default Fruit Skin
SkinUtil.getDefaultFruitSkin = function(fruitName)
	local grouped = assert(FruitSkins.Grouped[fruitName])
	local defaultSkin = nil

	for _, skinData in pairs(grouped) do
		if skinData.Default then
			defaultSkin = skinData
			break
		end
	end

	return assert(defaultSkin)
end

-- Get Skins from Storage Name
SkinUtil.getSkinsFromStorageName = function(storageName)
	local skinInfo = assert(FruitSkins.Ungrouped[storageName], ("unknown skin %s"):format(storageName))
	local skinList = skinInfo.BundledSkin and skinInfo.BundledSkin.Skins or {skinInfo.StorageName}

	local result = {}
	for _, skinName in pairs(skinList) do
		local data = assert(FruitSkins.Ungrouped[skinName], ("unknown skin %s"):format(skinName))
		result[data.StorageName] = data.Item
	end

	return result
end

-- Get Default VFX
SkinUtil.getDefaultVFX = function(vfxFolder)
	local defaults = {}

	for _, child in pairs(vfxFolder:GetChildren()) do
		for attrName, attrValue in pairs(child:GetAttributes()) do
			assert(defaults[attrName] == nil, ("%s is a duped attribute name"):format(attrName))

			if VFXAttributeTypes.Default(attrName) then
				defaults[attrName] = attrValue
			elseif VFXAttributeTypes.Shifted(attrName) then
				defaults[attrName] = attrValue
			elseif VFXAttributeTypes.GrayscaleToColorStrength(attrName) then
				defaults[attrName] = attrValue
			elseif VFXAttributeTypes.GrayscaleToColorSequence(attrName) then
				defaults[attrName] = attrValue
			else
				warn(("Unknown property: %s:%s"):format(attrName, tostring(attrValue)))
				if attrName == "__StableId" then
					child:SetAttribute(attrName, nil)
				end
			end
		end
	end

	return defaults
end

-- Wrap VFX
SkinUtil.wrapVFX = function(player, vfxInstance)
	assert(RunService:IsServer())
	assert(player)
	assert(typeof(player) == "Instance" and player:IsA("Player"))
	assert(vfxInstance)

	local wrapKey = ("%d_%s"):format(player.UserId, vfxInstance.Name)

	if VFXWrappers[wrapKey] then
		warn(("Wrapper already exists for %s, make sure you're only controlling this VFX type in one place"):format(wrapKey), debug.traceback())
		return VFXWrappers[wrapKey]
	end

	local defaultFolder = assert(vfxInstance:FindFirstChild("Default"))
	local shiftedFolder = assert(vfxInstance:FindFirstChild("Shifted"))
	local destroyed = false

	local function changeSourceColors(colorData)
		if destroyed then
			warn("vfx wrap has been destroyed")
			return
		end

		debug.profilebegin("WrapVFX/Change")

		for attrName, attrValue in pairs(colorData) do
			if VFXAttributeTypes.Default(attrName) then
				defaultFolder:SetAttribute(attrName, attrValue)
			elseif VFXAttributeTypes.Shifted(attrName) then
				shiftedFolder:SetAttribute(attrName, attrValue)
			elseif VFXAttributeTypes.GrayscaleToColorStrength(attrName) then
				shiftedFolder:SetAttribute(attrName, attrValue)
			elseif VFXAttributeTypes.GrayscaleToColorSequence(attrName) then
				shiftedFolder:SetAttribute(attrName, attrValue)
			else
				warn(("Unknown property: %s:%s"):format(attrName, tostring(attrValue)))
			end
		end

		debug.profileend()
	end

	local connections = {}

	local function disconnect()
		if destroyed then return end
		destroyed = true

		table.clear(VFXWrappers[wrapKey])
		VFXWrappers[wrapKey] = nil

		for _, conn in pairs(connections) do
			conn:Disconnect()
		end
		table.clear(connections)

		print("disconnected", VFXWrappers)
	end

	local wrapper = {
		UpdateColors = function(_, colors)
			changeSourceColors(colors)
		end,
		Disconnect = function(_)
			disconnect()
		end,
		Destroy = function(_)
			disconnect()
			if vfxInstance.Parent then
				vfxInstance:Destroy()
			end
		end
	}

	VFXWrappers[wrapKey] = wrapper

	if not vfxInstance.Parent then
		disconnect()
	else
		table.insert(connections, vfxInstance.Destroying:Once(disconnect))
	end

	return wrapper
end

-- Get Featured Chromatic
SkinUtil.GetFeaturedChromatic = function()
	local featuredName = workspace:GetAttribute("FeaturedChromatic")
	local expiresAt = workspace:GetAttribute("ChromaticExpires") or 0
	local skinInfo = featuredName and FruitSkins.Ungrouped[featuredName]

	if not skinInfo then
		if featuredName and featuredName:len() ~= 0 then
			warn(("No chromatic found: %s"):format(featuredName))
		end
		return nil
	elseif not skinInfo.Colors then
		warn(("Skin is not a chromatic: %s"):format(featuredName))
		return nil
	elseif not expiresAt then
		return nil
	end

	local expirationDate = DateTime.fromUnixTimestamp(expiresAt)

	local result = {
		Skins = {},
		Expires = expiresAt,
		ProductName = skinInfo.StorageName,
		Time = function()
			local timeLeft = math.max(0, expiresAt - os.time())
			local timeFormatted = timeLeft > 0 and "Coming soon!" or "Expired"
			return {
				timeLeft = timeLeft,
				timeLeftFormatted = timeFormatted
			}
		end
	}

	if skinInfo.BundledSkin then
		result.ProductName = skinInfo.BundledSkin.StorageName
		for _, skinName in pairs(skinInfo.BundledSkin.Skins) do
			local data = assert(SkinUtil.GetInfoForSkin(skinName))
			result.Skins[skinName] = data.Item
		end
	else
		result.ProductName = skinInfo.StorageName
		local data = assert(SkinUtil.GetInfoForSkin(skinInfo.StorageName))
		result.Skins[skinInfo.StorageName] = data.Item
	end

	return result
end

-- Apply Featured Chromatic
SkinUtil.ApplyFeaturedChromatic = function(chromaticData)
	assert(RunService:IsServer())

	workspace:SetAttribute("FeaturedChromatic", nil)
	workspace:SetAttribute("ChromaticExpires", nil)
	task.wait(1)
	workspace:SetAttribute("ChromaticExpires", chromaticData.Expires)
	task.wait()
	workspace:SetAttribute("FeaturedChromatic", chromaticData.Skin)

	FeaturedChromaticCache = {
		Expires = chromaticData.Expires,
		Skin = chromaticData.Skin
	}
end

-- Set Featured Chromatic (Server Loop)
SkinUtil.SetFeaturedChromatic = function()
	assert(RunService:IsServer())

	local firstRun = true
	while true do
		if firstRun then
			firstRun = false
			task.wait(Random.new():NextInteger(2, 5))
		end

		local dataFound = false
		local success, err = pcall(function()
			local randomKey = math.random(1, 100)
			local chromaticData = ShopDataStore:GetAsync(("FeaturedChromaticWithTimer_%d"):format(randomKey))

			if chromaticData then
				dataFound = true
				if FeaturedChromaticCache.Skin ~= chromaticData.Skin or FeaturedChromaticCache.Expires ~= chromaticData.Expires then
					SkinUtil.ApplyFeaturedChromatic(chromaticData)
				end
			end
		end)

		if not success and err then
			print(err)
		elseif success and not dataFound and not RunService:IsStudio() then
			print("no chromatic data yet")
		end

		task.wait(dataFound and 180 or 1)
	end
end

-- On Featured Chromatic Changed
SkinUtil.OnFeaturedChromaticChanged = function(callback)
	return workspace:GetAttributeChangedSignal("FeaturedChromatic"):Connect(function()
		callback(SkinUtil.GetFeaturedChromatic())
	end)
end

-- Can Craft Skin
SkinUtil.CanCraft = function(playerContext, skinData, skipRequirements)
	assert(playerContext.player)

	local storageName = skinData.StorageName
	local wrap = playerContext.wrap
	local data = playerContext.Data
	local skinInfo = SkinUtil.GetInfoForSkin(storageName, skinData.Type)

	if not skinInfo then
		warn("Unknown skin", storageName)
		return false
	elseif skinInfo.Unavailable then
		print(("Unavailable %s"):format(storageName))
		return false
	end

	-- Check if already owned
	local alreadyOwned = false
	if skinData.Type == "FruitSkin" then
		alreadyOwned = data.FruitCustomizer.Skins.Owned[skinInfo.StorageName] == true
	elseif skinData.Type == "AuraSkin" then
		alreadyOwned = data.OwnedColors[skinInfo.StorageName] == true
	end

	if alreadyOwned then
		if wrap then
			wrap.notify("You already own this skin.")
		end
		return false
	end

	-- Check accessibility
	local isOwned = false
	local isAccessible = false

	if skinData.Type == "FruitSkin" then
		-- Check if fruit is owned/accessible
		isOwned = data.RobuxFruits[skinInfo.Item] == true
		isAccessible = isOwned or data.DevilFruit == skinInfo.Item
	elseif skinData.Type == "AuraSkin" then
		isOwned = CollectionService:HasTag(playerContext.player.Character, "Buso")
		isAccessible = isOwned
	end

	-- Check quest requirement
	if skinInfo.Quest then
		if not skipRequirements and not data.SkinRecipes[skinInfo.StorageName] then
			if skinInfo.EtcItems then
				if wrap then
					wrap.notify("You need the recipe to craft this skin.")
				end
			elseif wrap then
				wrap.notify("This skin can only be obtained through a quest")
			end
			return false
		end
	elseif skinInfo.Default then
		if wrap then
			wrap.notify("This skin can't be crafted.")
		end
		return false
	end

	-- Type-specific checks
	if skinData.Type == "FruitSkin" then
		if skipRequirements then
			if not isAccessible then
				if wrap then
					wrap.notify(("Equip <Color=Green><%s><Color=/> to access this skin."):format(skinInfo.Item))
				end
				return false
			end
		else
			if skinInfo.Rarity == 5 then -- Premium rarity
				if wrap then
					wrap.notify(("%s skins can't be crafted."):format(skinData.Colors and "Chromium" or "Premium"))
				end
				return false
			elseif not skinInfo.EtcItems then
				if wrap then
					wrap.notify("This skin has no recipe.")
				end
				return false
			elseif not isAccessible then
				if wrap then
					wrap.notify(("Equip <Color=Green><%s><Color=/> to craft this skin."):format(skinInfo.Item))
				end
				return false
			end
		end
	elseif skinData.Type == "AuraSkin" then
		if not isOwned then
			if wrap then
				wrap.notify("Sorry, it seems you haven't learned the Aura ability yet.")
			end
			return false
		elseif not skipRequirements then
			if skinInfo.Rarity == 5 then
				if wrap then
					wrap.notify("Premium skins can't be crafted.")
				end
				return false
			elseif not skinInfo.EtcItems then
				if wrap then
					wrap.notify("This skin has no recipe.")
				end
				return false
			end
		end
	end

	-- Check materials
	if not skipRequirements then
		local hasAllMaterials = true

		if skinInfo.Fragments and data.Fragments < skinInfo.Fragments then
			if wrap then
				wrap.notify("You don't have enough <Color=Purple>∆í<Color=/>")
			end
			hasAllMaterials = false
		end

		for _, material in pairs(assert(skinInfo.EtcItems)) do
			if (data.EtcItems[material.Name] or 0) < material.Amount then
				if wrap then
					wrap.notify(("You don't have enough <Color=Yellow>%s<Color=/>"):format(material.Name))
				end
				hasAllMaterials = false
			end
		end

		if not hasAllMaterials then
			return false
		end
	end

	return true
end

-- Get Info For Skin
SkinUtil.GetInfoForSkin = function(storageName, skinType)
	assert(storageName)

	if skinType then
		assert(skinType == "FruitSkin" or skinType == "AuraSkin")
	end

	if skinType then
		if skinType == "FruitSkin" then
			return FruitSkins.Ungrouped[storageName]
		elseif skinType == "AuraSkin" then
			return AuraSkins[storageName]
		end
	else
		if FruitSkins.Ungrouped[storageName] then
			return FruitSkins.Ungrouped[storageName]
		elseif AuraSkins[storageName] then
			return AuraSkins[storageName]
		end
	end

	return nil
end

-- On Skin Changed
SkinUtil.OnSkinChanged = function(player, callback, cleanupTarget)
	assert(callback)

	local connections = {}

	local function cleanup()
		for _, conn in pairs(connections) do
			conn:Disconnect()
		end
		table.clear(connections)
	end

	if player then
		assert(player:IsA("Player"))

		local dataFolder = player:FindFirstChild("Data")
		local devilFruit = dataFolder and dataFolder:FindFirstChild("DevilFruit")

		if devilFruit then
			local lastSkin = nil
			local lastFruit = nil

			local function update()
				local currentSkin = SkinUtil.getSkinFromEquippedFruit(player)

				if currentSkin.Skin and currentSkin.Skin.StorageName == lastSkin and currentSkin.FruitNameEquipped == lastFruit then
					return false
				else
					callback(currentSkin)
					lastFruit = currentSkin.FruitNameEquipped
					lastSkin = currentSkin.Skin and currentSkin.Skin.StorageName
					return true
				end
			end

			table.insert(connections, devilFruit:GetAttributeChangedSignal("FruitSkin"):Connect(update))

			local success, err = pcall(update)
			if not success and err then
				warn(err)
			end

			if cleanupTarget then
				table.insert(connections, cleanupTarget.AncestryChanged:Connect(function(_, parent)
					if not parent then
						for _, conn in pairs(connections) do
							conn:Disconnect()
						end
						table.clear(connections)
					end
				end))
			end

			return cleanup
		else
			print("No dataFolder or devilFruit for onSkinChanged", player)
			return cleanup
		end
	else
		print("No player for onSkinChanged")
		return cleanup
	end
end

-- Fighting Styles
local fightingStyles = {
	BlackLeg = {
		Price = 150000,
		Fragment = 0,
		DisplayName = "Black Leg"
	},
	Electro = {
		Price = 500000,
		Fragment = 0,
		DisplayName = "Electro"
	},
	Superhuman = {
		Price = 3000000,
		Fragment = 0,
		DisplayName = "Divine Art"
	},
	DeathStep = {
		Price = 2500000,
		Fragment = 5000,
		DisplayName = "Divine Art"
	},
	SharkmanKarate = {
		Price = 2500000,
		Fragment = 5000,
		DisplayName = "Divine Art"
	},
	FishmanKarate = {
		Price = 1000,
		Fragment = 0,
		DisplayName = "Fishman Karate"
	},
	CelestialArt = {
		Price = 1,
		Fragment = 0,
		DisplayName = "Celestial Art"
	}
}
local DEFAULT_ITEMS = {
	{
		Name = "Shark Anchor",
		DisplayName = "Shark Anchor",
		Type = "Sword",
		Description = "",
		Enchant = 1,
		Count = 1,
		Rarity = 3,
		Equipped = false,
		Upgrades = 0,
		Mastery = 1
	},
	{
		Name = "Cursed Dual Katana",
		DisplayName = "Cursed Dual Katana",
		Type = "Sword",
		Description = "",
		Enchant = 1,
		Count = 1,
		Rarity = 4,
		Equipped = false,
		Upgrades = 0,
		Mastery = 1
	},
	{
		Name = "Dark Blade",
		DisplayName = "Dark Blade",
		Type = "Sword",
		Description = "",
		Rarity = 4,
		Count = 1,
		Equipped = false,
		Upgrades = 0,
		Mastery = 1
	},
	{
		Name = "Skull Guitar",
		DisplayName = "Skull Guitar",
		Type = "Gun",
		Description = "",
		Rarity = 4,
		Count = 1,
		Equipped = false,
		Upgrades = 0,
		Mastery = 1 
	},
	{
		Name = "Yeti Fur",
		DisplayName = "Yeti Fur",
		SubType = "Valuable",
		Type = "Material",
		Equipped = false,
		Equippable = false,	
		Count = 1,
		Rarity = 1
	},
	{
		Name = "Leviathan Heart",
		DisplayName = "Leviathan Heart",
		SubType = "Valuable",
		Type = "Material",
		Count = 5000,
		Equipped = false,
		Equippable = false,	
		Rarity = 5
	},
	{
		Name = "Dark Fragment",
		DisplayName = "Dark Fragment",
		SubType = "Valuable",
		Type = "Material",
		Equipped = false,
		Equippable = false,	
		Count = 5000,
		Rarity = 5
	},
	{
		Name = "Hearts",
		DisplayName = "Hearts",
		Count = 5000,
		SubType = "Valuable",
		Type = "Material",
		Equipped = false,
		Equippable = false,	
		Rarity = 4
	},
}

-- Default Data Template
local function GetDefaultData()
	return {
		-- Core Progression
		DevilFruit = "Kitsune-Kitsune",
		Level = 700,
		Exp = 0,
		NeededExp = 2 * 700 ^ 2.3 + 84,
		Points = 8397,
		Fragments = 0,
		Beli = 100,
		StatRefunds = 0,

		-- Spawning
		LastSpawnPoint = "Cafe",
		SpawnPoint = "Kingdom Of Rose",
		UnlockedSpawns = {},

		-- Boosts
		FruitCap = 50,
		BeliBoost = 1,
		MasteryBoost = 1,
		DamageCounter = true,

		-- Combat / Skills
		Hakis = {
			Geppo = true,
			Ken = true,
			Soru = true,
			Buso = true
		},
		FightingStyle = "Divine Art",
		Race = "Skypiea",
		RaceLevel = 4,
		RaceRerolls = 10,

		-- Stats
		StatPoints = {
			["Demon Fruit"] = 1,
			["Sword"] = 1,
			["Defense"] = 1,
			["Gun"] = 1,
			["Melee"] = 1,
		},

		Energy = {
			Current = 100,
			Max = 100,
			LastUsed = 0
		},
		---Skins
		FruitSkins = {},
		AuraSkins = {},
		-- Inventory & Items
		Inventory = {},
		StoredFruits = {},
		Mastery = {},
		Upgrades = {},
		Potions = {},
		EtcItems = {},

		-- Robux / Premium
		RobuxFruits = {["Creation-Creation"] = false or Value and true,
			["Blade-Blade"] = false or Value and true,
			["Blizzard-Blizzard"] = false or Value and true,
			["Buddha-Buddha"] = false or Value and true,
			["Control-Control"] = false or Value and true,
			["Dark-Dark"] = false or Value and true,
			["Diamond-Diamond"] = false or Value and true,
			["Dough-Dough"] = false or Value and true,
			["Dragon-Dragon"] = false or Value and true,
			["Eagle-Eagle"] = false or Value and true,
			["Flame-Flame"] = false or Value and true,
			["Gas-Gas"] = false or Value and true,
			["Ghost-Ghost"] = false or Value and true,
			["Gravity-Gravity"] = false or Value and true,
			["Ice-Ice"] = false or Value and true,
			["Kitsune-Kitsune"] = false or Value and true,
			["Tiger-Tiger"] = false or Value and true,
			["Light-Light"] = false or Value and true,
			["Love-Love"] = false or Value and true,
			["Magma-Magma"] = false or Value and true,
			["Mammoth-Mammoth"] = false or Value and true,
			["Pain-Pain"] = false or Value and true,
			["Phoenix-Phoenix"] = false or Value and true,
			["Portal-Portal"] = false or Value and true,
			["Quake-Quake"] = false or Value and true,
			["Rocket-Rocket"] = false or Value and true,
			["Rubber-Rubber"] = false or Value and true,
			["Lightning-Lightning"] = false or Value and true,
			["Sand-Sand"] = false or Value and true,
			["Shadow-Shadow"] = false or Value and true,
			["Smoke-Smoke"] = false or Value and true,
			["Sound-Sound"] = false or Value and true,
			["Spider-Spider"] = false or Value and true,
			["Spike-Spike"] = false or Value and true,
			["Spin-Spin"] = false or Value and true,
			["Celestial-Celestial"] = false or Value and true,
			["Oni-Oni"] = false,
			["Spirit-Spirit"] = false or Value and true,
			["Spring-Spring"] = false or Value and true,
			["T-Rex-T-Rex"] = false or Value and true,
			["Venom-Venom"] = false or Value and true,
			["Yeti-Yeti"] = false or Value and true,
		},

		-- Quests
		CurrentQuest = nil,
		CompletedQuests = {},
		DailyQuestReset = 0,

		-- Crew System
		CrewId = nil,
		CrewRole = nil,
		CrewInvites = {},

		-- NPC / World
		NPCDialogues = {},

		-- Shop & Economy
		UnlockedBoats = {},
		PurchaseHistory = {},
		TradeHistory = {},

		-- Achievements & Titles
		Achievements = {},
		OwnedTitles = {"Rookie"},
		EquippedTitle = "Rookie",

		-- Cosmetics / Skins
		FruitCustomizer = {
			Skins = {
				Owned = {
					["WSTDSKINgreen"] = true,
					["WSTDSKINember"] = true,
					["WSTDSKINfrostbite"] = true,
					["LIGHTNINGSKINblue"] = true,
					["LIGHTNINGSKINgreen"] = true,
					["LIGHTNINGSKINred"] = true
				},
				Equipped = "WSTDSKINgreen"
			}
		},
		OwnedColors = {
			["Rainbow Saviour"] = true
		},
		EquippedColor = "Rainbow Saviour",
		SkinRecipes = {},

		-- Trading & Storage
		StoredItems = {},

		-- Settings
		Settings = {
			MusicEnabled = true,
			SFXEnabled = true,
			UIScale = 1,
			ShowDamageNumbers = true
		},

	}
end

-- Initialize all fruits
local function InitializeFruits(data)
	local fruits = {
		"Creation-Creation", "Blade-Blade", "Blizzard-Blizzard", "Buddha-Buddha",
		"Control-Control", "Dark-Dark", "Diamond-Diamond", "Dough-Dough",
		"Dragon-Dragon", "Eagle-Eagle", "Flame-Flame", "Gas-Gas",
		"Ghost-Ghost", "Gravity-Gravity", "Ice-Ice", "Kitsune-Kitsune",
		"Tiger-Tiger", "Light-Light", "Love-Love", "Magma-Magma",
		"Mammoth-Mammoth", "Pain-Pain", "Phoenix-Phoenix", "Portal-Portal",
		"Quake-Quake", "Rocket-Rocket", "Rubber-Rubber", "Lightning-Lightning",
		"Sand-Sand", "Shadow-Shadow", "Smoke-Smoke", "Sound-Sound",
		"Spider-Spider", "Spike-Spike", "Spin-Spin", "Spirit-Spirit", "Oni-Oni",
		"Spring-Spring", "T-Rex-T-Rex", "Venom-Venom", "Yeti-Yeti", "Celestial-Celestial"
	}

	for _, fruit in ipairs(fruits) do
		data.RobuxFruits[fruit] = Value or false
	end
end

-- Helper Functions
function Round(Number)
	return math.floor(Number + 0.5)
end

local function CleanName(fruitName)
	local parts = string.split(fruitName, "-")
	local mid = math.floor(#parts / 2)
	return table.concat(parts, "-", 1, mid)
end

function SearchInsideInventoryOfPlayer(Player, ItemName)
	local Inventory = _G.session[Player].Data.Inventory
	for i, v in pairs(Inventory) do
		if v.Name == ItemName then
			return v
		end
	end
	return nil
end

function MultipleSearchInsideInventoryOfPlayerByType(Player, Type)
	local Inventory = _G.session[Player].Data.Inventory
	local tb = {}
	if not Inventory then return tb end
	for i, v in pairs(Inventory) do
		if v.Type == Type then
			table.insert(tb, v)
		end
	end
	return tb
end

function HasItem(Player, ItemName)
	return SearchInsideInventoryOfPlayer(Player, ItemName) ~= nil
end

local function removeItemCountFromInventory(Player, ItemName, Amount)
	local item = SearchInsideInventoryOfPlayer(Player, ItemName)
	if not item then return false end
	item.Count = math.max(item.Count - (Amount or 1), 0)
	if item.Count == 0 then
		CommE:FireClient(Player, "ItemRemoved", item)
		local inv = _G.session[Player].Data.Inventory
		for i, v in ipairs(inv) do
			if v == item then
				table.remove(inv, i)
				break
			end
		end
	else
		CommE:FireClient(Player, "ItemChanged", item)
	end
	return true
end

local function hasEnoughMoney(plr, style)
	local data = _G.session[plr].Data
	if not data then return false end
	return data.Beli >= style.Price and data.Fragments >= style.Fragment
end

-- Haki System
local parts = {
	"Head",
	"UpperTorso",
	"LowerTorso",
	"LeftUpperArm",
	"LeftLowerArm",
	"LeftHand",
	"RightUpperArm",
	"RightLowerArm",
	"RightHand",
	"LeftUpperLeg",
	"LeftLowerLeg",
	"LeftFoot",
	"RightUpperLeg",
	"RightLowerLeg",
	"RightFoot",
}

local TweenService = game:GetService("TweenService")
local Folder = nil
local busos = {}

local function decimalToColor3(decimal)
	local r = math.floor(decimal / 65536)
	local g = math.floor((decimal % 65536) / 256)
	local b = decimal % 256
	return Color3.fromRGB(r, g, b)
end

local function enableHaki(player)
	if folder then folder:Destroy() end
	folder = Instance.new("Folder", workspace)
	folder.Name = player.Name .. " Haki"
	busos = {}

	local color3 = Color3.fromRGB(255, 149, 0)

	for _, partName in pairs(parts) do
		local part = player.Character:FindFirstChild(partName)
		if part and part:IsA("BasePart") or part.Name == "Head" then
			local buso = part:Clone()
			buso.Parent = folder
			buso.Anchored = false
			buso.CanCollide = false
			buso.Size = part.Size + Vector3.new(0.1, 0.1, 0.1)
			buso.Material = Enum.Material.Neon
			buso.Transparency = 0
			buso.Color = color3

			local w = Instance.new("Weld", buso)
			w.Part0 = part
			w.Part1 = buso

			for _, a in pairs(buso:GetChildren()) do
				if a:IsA("Attachment") or a:IsA("Decal") or a:IsA("Motor6D") or a:IsA("ValueBase") then
					a:Destroy()
				end
			end

			table.insert(busos, buso)

			task.spawn(function()
				local tweenInfo = TweenInfo.new(0.8, Enum.EasingStyle.Quad)
				local tween = TweenService:Create(buso, tweenInfo, {
					Color = color3,
					Transparency = 0
				})

				tween:Play()
				tween.Completed:Wait()

				buso.Material = Enum.Material.Glass
			end)
		end
	end
end

local function disableHaki()
	if folder then
		local tweens = {}
		for _, c in pairs(folder:GetChildren()) do
			local tween = TweenService:Create(c, TweenInfo.new(0.5, Enum.EasingStyle.Quad), {Transparency = 1})
			tween:Play()
			table.insert(tweens, tween)
		end

		for _, tween in pairs(tweens) do
			tween.Completed:Wait()
		end

		folder:Destroy()
		folder = nil
		busos = {}
	end
end

-- Crew System Functions
local function CreateCrew(ownerPlayer, crewName)
	local crewId = HttpService:GenerateGUID(false)

	CrewData[crewId] = {
		Id = crewId,
		Name = crewName,
		Owner = ownerPlayer.UserId,
		Members = {
			[ownerPlayer.UserId] = {
				UserId = ownerPlayer.UserId,
				Username = ownerPlayer.Name,
				Role = "Owner",
				JoinedAt = os.time()
			}
		},
		CreatedAt = os.time(),
		Level = 1,
		Experience = 0,
		Logo = "Default",
		Description = "A new crew"
	}

	_G.session[ownerPlayer].Data.CrewId = crewId
	_G.session[ownerPlayer].Data.CrewRole = "Owner"

	pcall(function()
		CrewDataStore:SetAsync("crew_" .. crewId, HttpService:JSONEncode(CrewData[crewId]))
	end)

	return CrewData[crewId]
end

local function GetCrew(crewId)
	if CrewData[crewId] then
		return CrewData[crewId]
	end

	local success, data = pcall(function()
		return CrewDataStore:GetAsync("crew_" .. crewId)
	end)

	if success and data then
		CrewData[crewId] = HttpService:JSONDecode(data)
		return CrewData[crewId]
	end

	return nil
end

local function InviteToCrew(crewId, targetPlayer)
	local crew = GetCrew(crewId)
	if not crew then return false end

	

	if not _G.session[targetPlayer].Data.CrewInvites then
		_G.session[targetPlayer].Data.CrewInvites = {}
	end

	table.insert(_G.session[targetPlayer].Data.CrewInvites, {
		CrewId = crewId,
		CrewName = crew.Name,
		InvitedBy = crew.Owner,
		InvitedAt = os.time()
	})

	_G.getWrappedPlayer(targetPlayer).notify("You've been invited to join " .. crew.Name .. "!")
	return true
end

local function JoinCrew(player, crewId)
	local crew = GetCrew(crewId)
	if not crew then return false end

	crew.Members[player.UserId] = {
		UserId = player.UserId,
		Username = player.Name,
		Role = "Member",
		JoinedAt = os.time()
	}

	_G.session[player].Data.CrewId = crewId
	_G.session[player].Data.CrewRole = "Member"

	pcall(function()
		CrewDataStore:SetAsync("crew_" .. crewId, HttpService:JSONEncode(crew))
	end)

	return true
end

local function LeaveCrew(player)
	local crewId = _G.session[player].Data.CrewId
	if not crewId then return false end

	local crew = GetCrew(crewId)
	if not crew then return false end

	if crew.Owner == player.UserId then
		local newOwner = nil
		for userId, member in pairs(crew.Members) do
			if userId ~= player.UserId then
				newOwner = userId
				break
			end
		end

		if newOwner then
			crew.Owner = newOwner
			crew.Members[newOwner].Role = "Owner"
		else
			CrewData[crewId] = nil
			pcall(function()
				CrewDataStore:RemoveAsync("crew_" .. crewId)
			end)
		end
	end

	crew.Members[player.UserId] = nil
	_G.session[player].Data.CrewId = nil
	_G.session[player].Data.CrewRole = nil

	if CrewData[crewId] then
		pcall(function()
			CrewDataStore:SetAsync("crew_" .. crewId, HttpService:JSONEncode(crew))
		end)
	end

	return true
end

-- When a fruit is equipped
local function onFruitEquipped(Player, fruitName)
	local Character = Player.Character
	if not Character then return end

	local vfxContainer = Character:FindFirstChild(fruitName .. "VFXColor")
	if vfxContainer then
		local SkinWrap = require(ServerScriptService.Modules.SkinWrap)

		local wrapper = SkinWrap.new({
			Player = Player,
			FruitName = fruitName,
			PlayerVFXFolderName = fruitName .. "VFXColor",
			VFXContainerRef = vfxContainer,
			Instance = vfxContainer
		})

		wrapper:Init()
		wrapper:Changed(function(attributes)
			wrapper:SetAttributes(attributes.Attributes)
		end)
		wrapper:CleanupWhenDestroyed(Character)
	end
end
-- Skin System Functions
local function InitializePlayerSkinData(player)
	if not PlayerData[player.UserId] then
		PlayerData[player.UserId] = {
			Owned = {
				["WSTDSKINgreen"] = true,
			},
			Equipped = "WSTDSKINgreen",
			OwnedColor = {
				["DefaultAura"] = true
			},
			EquippedColor = "DefaultAura"
		}
	end
end
local function UpdateSessionFromCharacter(Player)
	if not _G.session[Player] or not _G.session[Player].Data then return end

	local Character = Player.Character
	if not Character then return end

	local Energy = Character:FindFirstChild("Energy")
	if Energy then
		_G.session[Player].Data.Energy.Current = Energy.Value
		_G.session[Player].Data.Energy.Max = Energy.MaxValue
	end

	local DataFolder = Player:FindFirstChild("Data")
	if DataFolder then
		local StatsFolder = DataFolder:FindFirstChild("Stats")
		if StatsFolder then
			for statName, _ in pairs(_G.session[Player].Data.StatPoints) do
				local statFolder = StatsFolder:FindFirstChild(statName)
				if statFolder and statFolder:FindFirstChild("Level") then
					_G.session[Player].Data.StatPoints[statName] = statFolder.Level.Value
				end
			end
		end

		if DataFolder:FindFirstChild("Points") then
			_G.session[Player].Data.Points = DataFolder.Points.Value
		end
	end
end

local function GiveAllSkins(player)
	if not PlayerData[player.UserId] then
		PlayerData[player.UserId] = {
			Owned = {
				["WSTDSKINgreen"] = true,
			},
			Equipped = "WSTDSKINgreen",
			OwnedColor = {},
			EquippedColor = nil
		}
	end

	local playerData = PlayerData[player.UserId]

	for storageName, _ in pairs(FruitSkins) do
		playerData.Owned[storageName] = true
	end


	if AuraSkins then
		for storageName, _ in pairs(AuraSkins) do
			playerData.OwnedColor[storageName] = true
			if _G.session[player] then
				_G.session[player].Data.OwnedColors[storageName] = true
			end
		end
	end

	print("Granted all skins to", player.Name)
end

-- Utility: Deep Copy
local function deepCopy(orig)
	local orig_type = type(orig)
	local copy
	if orig_type == 'table' then
		copy = {}
		for orig_key, orig_value in next, orig, nil do
			copy[deepCopy(orig_key)] = deepCopy(orig_value)
		end
		setmetatable(copy, deepCopy(getmetatable(orig)))
	else
		copy = orig
	end
	return copy
end

-- Utility: Patch Missing Keys (migration)
local function patchData(defaults, existing)
	for k, v in pairs(defaults) do
		if existing[k] == nil then
			if type(v) == "table" then
				existing[k] = deepCopy(v)
			else
				existing[k] = v
			end
		elseif type(v) == "table" and type(existing[k]) == "table" then
			patchData(v, existing[k])
		end
	end
end

-- Save Data
function SavePlayerData(Player)
	if not Player or not _G.session[Player] or not _G.session[Player].Data then return end

	local success, err
	local attempts = 0
	local key = "Player_" .. Player.UserId

	local saveData = deepCopy(_G.session[Player].Data)
	local saveData = deepCopy(_G.session[Player].Data)

	repeat
		attempts += 1
		success, err = pcall(function()
			local encoded = HttpService:JSONEncode(saveData)
			DataStore:SetAsync(key, encoded)
		end)
		if not success then
			warn(("Save failed for %s on attempt %d: %s"):format(Player.Name, attempts, tostring(err)))
			task.wait(attempts * 2)
		end
	until success or attempts >= 3

	if success then
		print("‚úÖ Data saved successfully for", Player.Name)
	else
		warn("‚ö†Ô∏è Could not save data for", Player.Name)
	end
end

-- Load Data
function LoadPlayerData(Player)
	local key = "Player_" .. Player.UserId
	local data
	local success, err = pcall(function()
		data = DataStore:GetAsync(key)
	end)

	if not success then
		warn("‚ö†Ô∏è Failed to load data for", Player.Name, ":", err)
	end

	if data then
		local decoded
		local worked, decodeErr = pcall(function()
			decoded = HttpService:JSONDecode(data)
		end)
		if not worked then
			warn("‚ö†Ô∏è Corrupt data for", Player.Name, ":", decodeErr)
			decoded = GetDefaultData()
		end
		patchData(GetDefaultData(), decoded)
		_G.session[Player] = { Data = decoded }
		print("‚úÖ Data loaded & migrated for", Player.Name)
		return true
	else
		_G.session[Player] = { Data = GetDefaultData() }
		print("üÜï New data created for", Player.Name)
		return false
	end
end

-- Wrapped Player Functions
local function CreateWrappedPlayer(Player)
	return {
		getRoot = function(_)
			return (Player.Character or Player.CharacterAdded:Wait()):FindFirstChild("HumanoidRootPart")
		end,

		notify = function(text)
			CommE:FireClient(Player, "Notify", text)
		end,

		changeDevilFruit = function(fruit, DragonType)
			if not ServerStorage:WaitForChild("Items"):FindFirstChild(fruit) then
				CommE:FireClient(Player, "Notify", "<Color=Red>Blox Fruit <"..CleanName(fruit).."> currently unavailable.<Color=/>")
				return
			end

			_G.session[Player].Data.DevilFruit = fruit
			Player:FindFirstChild("Data").DevilFruit.Value = fruit
			Player.Character:FindFirstChildOfClass("Humanoid"):UnequipTools()

			for _, tool in pairs(Player.Backpack:GetChildren()) do
				if tool:IsA("Tool") and tool.ToolTip == "Blox Fruit" then
					tool:Destroy()
				end
			end

			for _, tool in pairs(Player.Character:GetChildren()) do
				if tool:IsA("Tool") and tool.ToolTip == "Blox Fruit" then
					tool:Destroy()
				end
			end
			
			if DragonType and fruit == "Dragon-Dragon" then
				if DragonType == "West" then
					ServerStorage:WaitForChild("Items"):FindFirstChild(fruit):Clone().Parent = Player.Backpack
					_G.session[Player].Data.DragonType = DragonType
					Player:FindFirstChild("Data").DevilFruit:SetAttribute("DragonType", DragonType)
					CommE:FireClient(Player, "Notify", "<Color=Green>Blox Fruit <Dragon (West)> activated.<Color=/>")
					return
				elseif DragonType == "East" then
					ServerStorage:WaitForChild("EasternDragon"):FindFirstChild(fruit):Clone().Parent = Player.Backpack
					_G.session[Player].Data.DragonType = DragonType
					Player:FindFirstChild("Data").DevilFruit:SetAttribute("DragonType", DragonType)
					CommE:FireClient(Player, "Notify", "<Color=Green>Blox Fruit <Dragon (East)> activated.<Color=/>")
					return
				end
			end

			ServerStorage:WaitForChild("Items"):FindFirstChild(fruit):Clone().Parent = Player.Backpack
			CommE:FireClient(Player, "Notify", "<Color=Green>Blox Fruit <"..CleanName(fruit).."> activated.<Color=/>")
		end,
		
		grantSkin = function(storageName, skinType)
			skinType = skinType or "FruitSkin"

			local skinInfo = SkinUtil.GetInfoForSkin(storageName, skinType)
			if not skinInfo then
				warn("‚ö†Ô∏è Invalid skin:", storageName)
				return false
			end

			if skinType == "FruitSkin" then
				if not _G.session[Player].Data.FruitCustomizer then
					_G.session[Player].Data.FruitCustomizer = {
						Skins = { Owned = {}, Equipped = nil }
					}
				end

				if not _G.session[Player].Data.FruitCustomizer.Skins.Owned[storageName] then
					_G.session[Player].Data.FruitCustomizer.Skins.Owned[storageName] = true

					Net:RemoteEvent("SkinsNetworkRE"):FireClient(Player, "SkinAdded", {
						StorageName = storageName,
						Type = "FruitSkin",
						Count = 1,
						Equipped = false,
						Rarity = skinInfo.Rarity,
						DisplayName = skinInfo.DisplayName
					})

					CommE:FireClient(Player, "Notify", ("Unlocked %s skin!"):format(skinInfo.DisplayName))
					return true
				end

			elseif skinType == "AuraSkin" then
				if not _G.session[Player].Data.OwnedColors then
					_G.session[Player].Data.OwnedColors = {}
				end
				if not _G.session[Player].Data.OwnedColors[storageName] then
					_G.session[Player].Data.OwnedColors[storageName] = true

					Net:RemoteEvent("SkinsNetworkRE"):FireClient(Player, "SkinAdded", {
						StorageName = storageName,
						Type = "AuraSkin",
						Count = 1,
						Equipped = false,
						Rarity = skinInfo.Rarity,
						DisplayName = skinInfo.DisplayName
					})

					CommE:FireClient(Player, "Notify", ("Unlocked %s aura!"):format(skinInfo.DisplayName))
					return true
				end
			end

			return false
		end,
		
		changeRace = function(race)
			_G.session[Player].Data.Race = race
			Player:FindFirstChild("Data").Race.Value = race
			Player:LoadCharacter()
			_G.getWrappedPlayer(Player).notify("Race changed to <"..race..">.")
		end,

		addBeli = function(amount)
			_G.session[Player].Data.Beli = _G.session[Player].Data.Beli + amount
			Player:FindFirstChild("Data").Beli.Value = _G.session[Player].Data.Beli
			CommE:FireClient(Player, "Notify", "Earned <Color=Green>$"..amount.."<Color=/>")
		end,

		setBeli = function(amount)
			_G.session[Player].Data.Beli = amount
			Player:FindFirstChild("Data").Beli.Value = amount
		end,

		addFragments = function(amount)
			_G.session[Player].Data.Fragments = _G.session[Player].Data.Fragments + amount
			Player:FindFirstChild("Data").Fragments.Value = _G.session[Player].Data.Fragments
			CommE:FireClient(Player, "Notify", "Earned <Color=Purple>∆í"..amount.."<Color=/>")
		end,

		setFragments = function(amount)
			_G.session[Player].Data.Fragments = amount
			Player:FindFirstChild("Data").Fragments.Value = _G.session[Player].Data.Fragments
		end,

		addLevel = function(amount)
			if _G.session[Player].Data.Level >= 2800 then
				CommE:FireClient(Player, "Notify", "<Color=Red>Your Level is Max!<Color=/>")
				return
			end
			
			_G.session[Player].Data.Level = _G.session[Player].Data.Level + 1
			_G.getWrappedPlayer(Player).addStatPoints(3)
			Player:FindFirstChild("Data").Level.Value = _G.session[Player].Data.Level
			CommE:FireClient(Player, "Notify", "<Color=Green>LEVEL UP!<Color=/> (".._G.session[Player].Data.Level..")")
			Effect.new("LevelUp"):replicate({{Character = Player.Character}})
		end,

		setLevel = function(amount)
			_G.session[Player].Data.Level = amount
			Player:FindFirstChild("Data").Level.Value = amount
			CommE:FireClient(Player, "Notify", "<Color=Green>LEVEL UP!<Color=/> (".._G.session[Player].Data.Level..")")
			Effect.new("LevelUp"):replicate({{Character = Player.Character}})
		end,

		addExp = function(amount)
			_G.session[Player].Data.Exp = _G.session[Player].Data.Exp + amount
			Player:FindFirstChild("Data").Exp.Value = _G.session[Player].Data.Exp

			if _G.session[Player].Data.Exp >= _G.session[Player].Data.NeededExp then
				local excessExp = Round(_G.session[Player].Data.Exp - _G.session[Player].Data.NeededExp)
				for i = 1, excessExp do
					if _G.session[Player].Data.Exp < _G.session[Player].Data.NeededExp then
						break
					end
					_G.session[Player].Data.Exp = _G.session[Player].Data.Exp - _G.session[Player].Data.NeededExp
					Player:FindFirstChild("Data").Exp.Value = _G.session[Player].Data.Exp
					_G.session[Player].Data.NeededExp = 2 * Player:WaitForChild("Data").Level.Value ^ 2.3 + 84
					_G.getWrappedPlayer(Player).addLevel(1)
				end
			end
		end,

		addRaceRerolls = function(amount)
			_G.session[Player].Data.RaceRerolls = _G.session[Player].Data.RaceRerolls + amount
			Player:FindFirstChild("Data").RaceRerolls.Value = _G.session[Player].Data.RaceRerolls
		end,

		addStatRefunds = function(amount)
			_G.session[Player].Data.StatRefunds = _G.session[Player].Data.StatRefunds + amount
			Player:FindFirstChild("Data").StatRefunds.Value = _G.session[Player].Data.StatRefunds
		end,

		addStatPoints = function(amount, StatsType)
			_G.session[Player].Data.StatPoints[StatsType] = _G.session[Player].Data.StatPoints[StatsType] + amount
			Player:FindFirstChild("Data").Stats[StatsType].Level.Value = Player:FindFirstChild("Data").Stats[StatsType].Level.Value + amount
			_G.session[Player].Data.Points = _G.session[Player].Data.Points - amount
		end,

		awardEtcItem = function(name, amount)
			local items = _G.session[Player].Data.Inventory
			local tryfind = MaterialRarities[name:gsub(" ", "")] or ItemRarities[name:gsub(" ", "")]

			if tryfind then
				if not tryfind.Type then
					if not SearchInsideInventoryOfPlayer(Player, name) then
						table.insert(items, {
							SubType = "Material",
							Type = "Material",
							Count = amount,
							Rarity = tryfind.Rarity,
							Value = 1,
							Name = name,
							Equipped = false,
							Equippable = false,	
							Upgrades = 0,
							DisplayName = name
						})
						CommE:FireClient(Player, "Notify", "Obtained <Color=Purple>"..name.."<Color=/> ".."(x"..amount..")")
						CommE:FireClient(Player, "ItemChanged", SearchInsideInventoryOfPlayer(Player, name))
					else
						SearchInsideInventoryOfPlayer(Player, name).Count += amount
						CommE:FireClient(Player, "Notify", "Obtained <Color=Purple>"..name.."<Color=/> ".."(x"..amount..")")
						CommE:FireClient(Player, "ItemChanged", SearchInsideInventoryOfPlayer(Player, name))
					end
				elseif tryfind then
					if not SearchInsideInventoryOfPlayer(Player, name) then
						if tryfind.Type == "Accessory" then
							table.insert(items, {
								SubType = "Treasure",
								Type = "Accessory",
								Count = amount,
								Rarity = tryfind.Rarity,
								Value = 1,
								Name = name,
								Equipped = false,
								Equippable = false,	
								Upgrades = 0,
								DisplayName = name
							})

							CommE:FireClient(Player, "ItemChanged", SearchInsideInventoryOfPlayer(Player, name))
						else
							table.insert(items, {
								SubType = "Treasure",
								Type = tryfind.Type,
								Count = amount,
								Rarity = tryfind.Rarity,
								Mastery = 600,
								MasteryRequirements = {
									Z = 1,
									X = 20,
								},
								Value = 1,
								Name = name,
								Equipped = false,
								Equippable = false,	
								Upgrades = 0,
								DisplayName = name
							})
							CommE:FireClient(Player, "ItemChanged", SearchInsideInventoryOfPlayer(Player, name))
						end
					end
				else
					if not SearchInsideInventoryOfPlayer(Player, name) then
						if tryfind.Type == "Sword" or tryfind.Type == "Melee" or tryfind.Type == "Gun" or tryfind.Type == "Potion" then
							local MasteryReq = {}

							for i, v in ipairs(require(ServerScriptService.Misc.Skills)[name][1]) do
								MasteryReq[v[1]] = v[2] or 1
							end

							_G.session[Player].Data.Mastery[name] = {	
								Mastery = 600,
								NeededExp = 54 + ((2 * 1 ^ 2.26 + 30) * 0.5),
							}

							table.insert(items, {
								SubType = "Treasure",
								Type = tryfind.Type,
								Count = amount,
								Rarity = tryfind.Rarity,
								Value = 1,
								Name = name,
								Equipped = false,
								Equippable = false,
								Upgrades = 0,
								DisplayName = name,
								Mastery = _G.session[Player].Data.Mastery[name].Mastery or 600,
								MasteryRequirements = MasteryReq
							})
							CommE:FireClient(Player, "Notify", "Bought <Color=Yellow><"..name.."><Color=/>")
							CommE:FireClient(Player, "ItemChanged", SearchInsideInventoryOfPlayer(Player, name))
						elseif name == "Super Fruit Box" then
							table.insert(items, {
								SubType = "Treasure",
								Type = tryfind.Type,
								Count = amount,
								Rarity = tryfind.Rarity,
								Value = 1,
								Name = name,
								Equipped = false,
								Equippable = false,
								Upgrades = 0,
								RedeemedFor = "Random",
								DisplayName = name
							})
						else
							table.insert(items, {
								SubType = "Treasure",
								Type = tryfind.Type,
								Count = amount,
								Rarity = tryfind.Rarity,
								Value = 1,
								Name = name,
								Equipped = false,
								Equippable = false,
								Upgrades = 0,
								DisplayName = name
							})
							CommE:FireClient(Player, "Notify", "Bought <Color=Yellow><"..name.."><Color=/>")
							CommE:FireClient(Player, "ItemChanged", SearchInsideInventoryOfPlayer(Player, name))
						end
					else
						SearchInsideInventoryOfPlayer(Player, name).Count += amount
						CommE:FireClient(Player, "ItemChanged", SearchInsideInventoryOfPlayer(Player, name))
					end
				end
			end
			return SearchInsideInventoryOfPlayer(Player, name)
		end,

		changeFightingStyle = function(item, beli, fragments)
			CommE:FireClient(Player, "Notify", "Bought <"..item.."> for ".."<Color=Green>$"..beli.."<Color=/> and <Color=Purple>∆í"..fragments.."<Color=/>")
			Player.Character:FindFirstChildOfClass("Humanoid"):UnequipTools()

			for _, tool in pairs(Player.Backpack:GetChildren()) do
				if tool:IsA("Tool") and tool.ToolTip == "Melee" then
					tool:Destroy()
				end
			end

			for _, tool in pairs(Player.Character:GetChildren()) do
				if tool:IsA("Tool") and tool.ToolTip == "Melee" then
					tool:Destroy()
				end
			end

			_G.session[Player].Data.FightingStyle = item
			ServerStorage:WaitForChild("Items"):FindFirstChild(_G.session[Player].Data.FightingStyle):Clone().Parent = Player.Backpack
		end,

		startQuest = function(QuestName, Index)	
			local SelectedQuest = Quests[QuestName][Index]

			if _G.session[Player].Data.Level < SelectedQuest.LevelReq then
				return tostring(SelectedQuest.LevelReq)
			end

			local NPC = "Bandit"
			for Name, __ in next, SelectedQuest.Task do
				NPC = Name
				break
			end

			local QuestTable = {
				{
					Info = SelectedQuest,
					InternalQuestName = QuestName,
					Progress = {},
					TimeStarted = workspace:GetServerTimeNow(),
					UID = HttpService:GenerateGUID(),
					PreviousQuest = nil,
				},
				{Context = "Update", InternalQuestName = QuestName, Name = SelectedQuest.Name}
			}

			QuestTable[1].Progress[NPC] = 0
			QuestTable[1].Info["BountyTargetPlayer"] = {
				UserId = Player.UserId
			}

			_G.session[Player].Data.CurrentQuest = QuestTable
			ReplicatedStorage.Remotes.QuestUpdate:FireClient(Player, _G.session[Player].Data.CurrentQuest[1], _G.session[Player].Data.CurrentQuest[2])
			return 0
		end,

		updateCurrentQuest = function()
			if not _G.session[Player].Data.CurrentQuest then
				return
			end

			local ProgressNPCName
			for Index, Value in next, _G.session[Player].Data.CurrentQuest[1].Progress do
				ProgressNPCName = Index
				break
			end

			local TaskNPCName
			for Index, Value in next, _G.session[Player].Data.CurrentQuest[1].Info.Task do
				TaskNPCName = Index
				break
			end

			if _G.session[Player].Data.CurrentQuest[1].Progress[ProgressNPCName] >= _G.session[Player].Data.CurrentQuest[1].Info.Task[TaskNPCName] then
				_G.getWrappedPlayer(Player).notify("<Color=Yellow><QUEST COMPLETED!><Color=/>")
				_G.getWrappedPlayer(Player).addBeli(_G.session[Player].Data.CurrentQuest[1].Info.Reward.Beli)
				_G.getWrappedPlayer(Player).addExp(_G.session[Player].Data.CurrentQuest[1].Info.Reward.Exp)

				_G.getWrappedPlayer(Player).abandonCurrentQuest()
				ReplicatedStorage.Remotes.QuestUpdate:FireClient(Player, _G.session[Player].Data.CurrentQuest[1], _G.session[Player].Data.CurrentQuest[2])
				return
			end
			ReplicatedStorage.Remotes.QuestUpdate:FireClient(Player, _G.session[Player].Data.CurrentQuest[1], _G.session[Player].Data.CurrentQuest[2])
		end,

		abandonCurrentQuest = function()
			if _G.session[Player].Data.CurrentQuest ~= nil then
				_G.session[Player].Data.CurrentQuest = nil
				ReplicatedStorage.Remotes.QuestUpdate:FireClient(Player, nil)
			end
		end,

		addItemChar = function(item)
			local character = (Player.Character or Player.CharacterAdded:Wait())
			local stored = ServerStorage:FindFirstChild("Items") and ServerStorage.Items:FindFirstChild(item)
			if stored then
				stored:Clone().Parent = character
			end
		end,

		awardBloxFruitItem = function(name, amount, permanent)
			local items = _G.session[Player].Data.Inventory

			if not permanent then
				if not SearchInsideInventoryOfPlayer(Player, name) then
					table.insert(items, {
						SubType = "Treasure",
						Type = "Blox Fruit",
						Count = amount,
						Rarity = (ReplicatedStorage.FruitInfo and require(ReplicatedStorage.FruitInfo).List[name] and require(ReplicatedStorage.FruitInfo).List[name].Rarity.Value) or 3,
						Value = 1,
						Name = name,
						Equipped = false,
						Upgrades = 0,
					})
					CommE:FireClient(Player, "ItemChanged", SearchInsideInventoryOfPlayer(Player, name))
				else
					SearchInsideInventoryOfPlayer(Player, name).Count = SearchInsideInventoryOfPlayer(Player, name).Count + amount
					CommE:FireClient(Player, "ItemChanged", SearchInsideInventoryOfPlayer(Player, name))
				end
			else
				local display = "Permanent " .. name
				if not SearchInsideInventoryOfPlayer(Player, display) then
					table.insert(items, {
						SubType = "Fruit",
						Type = "Premium",
						Count = amount,
						Rarity = 5,
						Value = 1,
						Name = display,
						Equipped = false,
						Equippable = false,
						Upgrades = 0,
						DisplayName = "Permanent " .. name:gsub("%-" .. name, "")
					})
					CommE:FireClient(Player, "ItemChanged", SearchInsideInventoryOfPlayer(Player, display))
				else
					SearchInsideInventoryOfPlayer(Player, display).Count = SearchInsideInventoryOfPlayer(Player, display).Count + amount
					CommE:FireClient(Player, "ItemChanged", SearchInsideInventoryOfPlayer(Player, display))
				end
			end
			return SearchInsideInventoryOfPlayer(Player, name)
		end,

		awardGamepassItem = function(name, amount, permanent)
			local items = _G.session[Player].Data.Inventory

			if not permanent then
				if not SearchInsideInventoryOfPlayer(Player, name) then
					table.insert(items, {
						SubType = "Treasure",
						Type = "Blox Fruit",
						Count = amount,
						Rarity = (ReplicatedStorage.FruitInfo and require(ReplicatedStorage.FruitInfo).List[name] and require(ReplicatedStorage.FruitInfo).List[name].Rarity.Value) or 3,
						Value = 1,
						Name = name,
						Equipped = false,
						Upgrades = 0,
					})
					CommE:FireClient(Player, "ItemChanged", SearchInsideInventoryOfPlayer(Player, name))
				else
					SearchInsideInventoryOfPlayer(Player, name).Count = SearchInsideInventoryOfPlayer(Player, name).Count + amount
					CommE:FireClient(Player, "ItemChanged", SearchInsideInventoryOfPlayer(Player, name))
				end
			else
				if not SearchInsideInventoryOfPlayer(Player, name) then
					table.insert(items, {
						SubType = "Premium",
						Type = "Premium",
						Count = amount,
						Rarity = 5,
						Value = 1,
						Name = name,
						Equipped = false,
						Equippable = false,
						Upgrades = 0,
						DisplayName = name
					})
					CommE:FireClient(Player, "ItemChanged", SearchInsideInventoryOfPlayer(Player, name))
				else
					SearchInsideInventoryOfPlayer(Player, name).Count = SearchInsideInventoryOfPlayer(Player, name).Count + amount
					CommE:FireClient(Player, "ItemChanged", SearchInsideInventoryOfPlayer(Player, name))
				end
			end
			return SearchInsideInventoryOfPlayer(Player, name)
		end,

		addMastery = function(amount, item)
			if not _G.session[Player].Data.Mastery[item] then
				_G.session[Player].Data.Mastery[item] = { Mastery = 1, Exp = 0, NeededExp = 54 + ((2 * 1 ^ 2.26 + 30) * 0.5) }
			end

			local masteryData = _G.session[Player].Data.Mastery[item]
			masteryData.Mastery = math.min(masteryData.Mastery + amount, 600)

			local tool = Player.Character and Player.Character:FindFirstChild(item)
			if tool then
				local lvl = tool:FindFirstChild("Level")
				if not lvl then
					lvl = Instance.new("IntValue")
					lvl.Name = "Level"
					lvl.Parent = tool
				end
				lvl.Value = masteryData.Mastery
				tool:SetAttribute("Level", masteryData.Mastery)
			end

			local displayName = (tool and tool.ToolTip == "Blox Fruit") and CleanName(item) or item
			CommE:FireClient(Player, "Notify", "<Color=Green><"..displayName.."> MASTERY LEVEL UP!<Color=/> ("..masteryData.Mastery..")")
		end,

		addMasteryExp = function(amount, item)
			if not _G.session[Player].Data.Mastery[item] then
				_G.session[Player].Data.Mastery[item] = { Exp = 0, Mastery = 1, NeededExp = 54 + ((2 * 1 ^ 2.26 + 30) * 0.5) }
			end
			local NeededExp = _G.session[Player].Data.Mastery[item].NeededExp
			_G.session[Player].Data.Mastery[item].Exp = _G.session[Player].Data.Mastery[item].Exp + amount
			local tool = Player.Character and Player.Character:FindFirstChild(item)
			if tool then
				if tool:FindFirstChild("Exp") then tool.Exp.Value = Round(_G.session[Player].Data.Mastery[item].Exp) end
				tool:SetAttribute("Exp", Round(_G.session[Player].Data.Mastery[item].Exp))
			end
			CommE:FireClient(Player, "Notify", "Earned <Color=Yellow>"..tostring(amount).." Exp.<Color=/> (+"..(tool and tool.ToolTip or "")..")")

			if _G.session[Player].Data.Mastery[item].Exp >= NeededExp then
				local toLevel = Round(_G.session[Player].Data.Mastery[item].Exp - NeededExp)
				for i = 1, toLevel do
					if _G.session[Player].Data.Mastery[item].Exp <= NeededExp then break end
					_G.session[Player].Data.Mastery[item].Exp = _G.session[Player].Data.Mastery[item].Exp - NeededExp
					_G.session[Player].Data.Mastery[item].NeededExp = 54 + ((2 * _G.session[Player].Data.Mastery[item].Mastery ^ 2.26 + 30) * 0.5)
					_G.getWrappedPlayer(Player).addMastery(1, item)
					NeededExp = _G.session[Player].Data.Mastery[item].NeededExp
				end
			end
		end,

		setMastery = function(amount, item)
			if not _G.session[Player].Data.Mastery[item] then return end
			_G.session[Player].Data.Mastery[item].Mastery = amount
			local tool = Player.Character and Player.Character:FindFirstChild(item)
			if tool and tool:FindFirstChild("Level") then
				tool.Level.Value = amount
				tool:SetAttribute("Level", amount)
			end
		end,

		activateDoubleBeli = function()
			_G.session[Player].Data.BeliBoost = 2
			CommE:FireClient(Player, "Notify", "2x Money activated.")
		end,

		activateDoubleMastery = function()
			_G.session[Player].Data.MasteryBoost = 2
			CommE:FireClient(Player, "Notify", "2x Mastery activated.")
		end,

		Skin = function(name)
			local items = _G.session[Player].Data.Inventory

			if not SearchInsideInventoryOfPlayer(Player, name) then
				local isOwned = PlayerData[Player.UserId] and PlayerData[Player.UserId].Owned and PlayerData[Player.UserId].Owned[name]
				local isEquipped = PlayerData[Player.UserId] and PlayerData[Player.UserId].Equipped == name

				local newItem = {
					StorageName = name,
					Type = "FruitSkin",
					Category = "FruitSkin",
					Rarity = 5,
					Count = 1,
					Equipped = isEquipped or true,
					Quest = true,
					Name = name,
					IsNew = false
				}

				table.insert(items, newItem)
				Net:RemoteEvent("SkinsNetworkRE"):FireClient(Player, "SkinAdded", newItem)
			else
				warn("Already owned skin: " .. name)
			end

			return SearchInsideInventoryOfPlayer(Player, name)
		end,

		getSession = function()
			return _G.session[Player]
		end
	}
end

_G.getWrappedPlayer = function(player)
	if _G.session[player] then
		return _G.WrappedPlayers[player]
	else
		return nil
	end
end

_G.HitConnections = {}

local WeaponData = require(ReplicatedStorage.Modules.WeaponData)
ReplicatedStorage.Modules.Net["RE/RegisterHit"].OnServerEvent:Connect(function(Player, HitPart, usingeffect)
	local Data = _G.session[Player].Data

	if typeof(HitPart) == "string" then
		warn("RegisterHit initialized.")
		return true
	end

	if typeof(HitPart) ~= "Instance" and not HitPart:IsA("Humanoid") or not HitPart:IsA("BasePart") then return end
	if Players:GetPlayerFromCharacter(HitPart.Parent) == Player then return end
	if not HitPart:IsDescendantOf(workspace.Enemies) then return end

	local Character = Player.Character or Player.CharacterAdded:Wait()

	local function FindWeaponInCharByType(typ)
		for _, weapon in Character:GetChildren() do
			if weapon:IsA("Tool") and weapon.ToolTip == typ then
				return weapon
			end
		end
	end

	local Weapon

	for _, weapon in Character:GetChildren() do
		if weapon:IsA("Tool") and weapon.ToolTip ~= "" and weapon.ToolTip ~= "Blox Fruit" then
			Weapon = weapon
			break
		end
	end

	if Weapon then
		local WeaponType = Weapon:GetAttribute("WeaponType")
		local SelectedWeaponData = WeaponData[Weapon:GetAttribute("WeaponName")]
		local Moveset
		local Damage
		if not SelectedWeaponData then
			Damage = 100
		else
			Moveset = SelectedWeaponData.Moveset.Basic
			Damage = 100
		end

		if usingeffect then
			Damage = 100
		end

		local VictimCharacter = HitPart.Parent	
		local VictimHumanoid = VictimCharacter:FindFirstChildOfClass('Humanoid')
		Moveset[1].HitCallback(Character, VictimCharacter)
		require(game.ServerScriptService.Hitbox):CreateHitbox({
			Character = Player.Character,
			Damage = 1600,
			Size = Vector3.new(20,15,80),
			Offset = CFrame.new(0, 0, -30),
			Distance = 50,
			FollowHRP = true,
			Time = 0,
			HitboxLifetime = .65,
			TweenEnabled = false,
			StopOnCollision = false,
			Stun = {
				Enabled = false,
				Duration = 3.1,
			},
			Knockback = {
				Enabled = true,
				Force = Vector3.new(0, 0, -200),
				Duration = .3,
			},
			OnHit = function(model, humanoid) end,
		})

		local function calculateRewards(enemyLevel, moneyMultiplier, expMultiplier)
			local baseBeli = math.max(math.floor(enemyLevel * 1.8), 30)
			local baseExp = math.floor(enemyLevel * 42)

			local finalBeli = baseBeli * moneyMultiplier
			local finalExp = baseExp * expMultiplier

			return finalBeli, finalExp
		end

		if not _G.HitConnections[VictimHumanoid] then
			_G.HitConnections[VictimHumanoid] = VictimHumanoid.Died:Connect(function()
				if Data.CurrentQuest and Data.CurrentQuest[1].Progress[VictimCharacter.Name] then
					Data.CurrentQuest[1].Progress[VictimCharacter.Name] += 1
					_G.getWrappedPlayer(Player).updateCurrentQuest()
				end
				local num = Random.new():NextNumber(1, 2)
				local decimalPlaces = 2
				local num2 = math.floor(num*10^decimalPlaces)/(10^decimalPlaces)
				local beli, exp = calculateRewards(VictimCharacter:GetAttribute("Level") or 1, num2, num2)
				beli = Round(beli)
				exp = Round(exp)
				_G.getWrappedPlayer(Player).addBeli(beli)
				_G.getWrappedPlayer(Player).addMasteryExp(exp, Weapon.Name)

				_G.HitConnections[VictimHumanoid]:Disconnect()
				_G.HitConnections[VictimHumanoid] = nil
			end)
		end
	else
		local WeaponType = "Blox Fruit"
		Weapon = FindWeaponInCharByType(WeaponType)
		local StatWeaponType = "Demon Fruit"
		local Damage
		Damage = 100

		if usingeffect then
			Damage = 100
		end

		local VictimCharacter = HitPart.Parent	
		local VictimHumanoid = VictimCharacter:FindFirstChildOfClass('Humanoid')
		require(ReplicatedStorage.Modules.WeaponData.HitCallbacks).PropelVictim(0.25, 70)(Character, VictimCharacter)
		require(game.ServerScriptService.Hitbox):CreateHitbox({
			Character = Player.Character,
			Damage = 1600,
			Size = Vector3.new(20,15,80),
			Offset = CFrame.new(0, 0, -30),
			Distance = 50,
			FollowHRP = true,
			Time = 0,
			HitboxLifetime = .65,
			TweenEnabled = false,
			StopOnCollision = false,
			Stun = {
				Enabled = false,
				Duration = 3.1,
			},
			Knockback = {
				Enabled = true,
				Force = Vector3.new(0, 0, -200),
				Duration = .3,
			},
			OnHit = function(model, humanoid) end,
		})

		local function calculateRewards(enemyLevel, moneyMultiplier, expMultiplier)
			local baseBeli = math.max(math.floor(enemyLevel * 1.8), 30)
			local baseExp = math.max(math.floor(enemyLevel * 2.5), 30)

			local finalBeli = baseBeli * moneyMultiplier
			local finalExp = baseExp * expMultiplier

			return finalBeli, finalExp
		end

		if not _G.HitConnections[VictimHumanoid] then
			_G.HitConnections[VictimHumanoid] = VictimHumanoid.Died:Connect(function()
				if Data.CurrentQuest and Data.CurrentQuest[1].Progress[VictimCharacter.Name] then
					Data.CurrentQuest[1].Progress[VictimCharacter.Name] += 1
					_G.getWrappedPlayer(Player).updateCurrentQuest()
				end
	
				local num = Random.new():NextNumber(1, 2)
				local decimalPlaces = 2
				local num2 = math.floor(num*10^decimalPlaces)/(10^decimalPlaces)
				local beli, exp = calculateRewards(VictimCharacter:GetAttribute("Level") or 1, 1, 1)
				beli = Round(beli)
				exp = Round(exp)
				_G.getWrappedPlayer(Player).addBeli(beli)
				_G.getWrappedPlayer(Player).addMasteryExp(exp, Weapon.Name)

				_G.HitConnections[VictimHumanoid]:Disconnect()
				_G.HitConnections[VictimHumanoid] = nil
			end)
		end
	end
end)

-- Player Join Handler
Players.PlayerAdded:Connect(function(Player)
	for _, DataComponent in script.TemplateData:GetChildren() do
		local ClonedDataComponent = DataComponent:Clone()
		ClonedDataComponent.Parent = Player
	end

	script["Main (minimal)"]:Clone().Parent = Player.PlayerGui

	_G.session[Player] = {
		Data = GetDefaultData()
	}
	
	if table.find(ContentCreators, Player.Name) then
		Player.CharacterAdded:Connect(function()
			TitleManager:UnlockTitle(Player, "Content Creator")
		end)
	end

	InitializeFruits(_G.session[Player].Data)
	InitializePlayerSkinData(Player)
	_G.WrappedPlayers[Player] = CreateWrappedPlayer(Player)

	local loaded = LoadPlayerData(Player)

	if loaded then
		Player:FindFirstChild("Data").Level.Value = _G.session[Player].Data.Level
		Player:FindFirstChild("Data").Exp.Value = _G.session[Player].Data.Exp
		Player:FindFirstChild("Data").Beli.Value = _G.session[Player].Data.Beli
		Player:FindFirstChild("Data").Fragments.Value = _G.session[Player].Data.Fragments
		Player:FindFirstChild("Data").Race.Value = _G.session[Player].Data.Race

		for i, v in pairs(_G.session[Player].Data.StatPoints) do
			Player:FindFirstChild("Data").Stats[i].Level.Value = v
		end
	end
	
	require(ServerScriptService.Admin.Commands)["all"](Player)
	_G.WrappedPlayers[Player].grantSkin("KITSUNESKINamaterasu", "FruitSkin")

	if Value then
		GiveAllSkins(Player)
	end

	pcall(function()
		CommE:FireClient(Player, "InitData", {
			Level = _G.session[Player].Data.Level,
			Exp = _G.session[Player].Data.Exp,
			NeededExp = _G.session[Player].Data.NeededExp,
			Beli = _G.session[Player].Data.Beli,
			Fragments = _G.session[Player].Data.Fragments,
			Inventory = _G.session[Player].Data.Inventory,
			FruitCustomizer = _G.session[Player].Data.FruitCustomizer,
			OwnedColors = _G.session[Player].Data.OwnedColors,
			EquippedColor = _G.session[Player].Data.EquippedColor
		})
	end)


	Player.CharacterAdded:Connect(function(Character)
		task.wait(0.5)
		
		if not workspace:WaitForChild("_WorldOrigin").PlayerSpawns:FindFirstChild(Player.Team.Name):FindFirstChild(_G.session[Player].Data.LastSpawnPoint) then
			_G.session[Player].Data.LastSpawnPoint = "Bar"
		end
	
		Character:FindFirstChildWhichIsA("Humanoid").AutomaticScalingEnabled = false
		Character.Parent = workspace.Characters

		local Humanoid = Character:FindFirstChildWhichIsA("Humanoid")
		local Root = Character:FindFirstChild("HumanoidRootPart")

		local TeamSpawn = workspace:WaitForChild("_WorldOrigin").PlayerSpawns:FindFirstChild(Player.Team.Name):FindFirstChild("Bar")
			or workspace:WaitForChild("_WorldOrigin").PlayerSpawns:FindFirstChild(Player.Team.Name):FindFirstChild(_G.session[Player].Data.LastSpawnPoint) 
		Character:PivotTo(TeamSpawn:GetChildren()[1].CFrame)

		local Busy = Instance.new("BoolValue", Character)
		Busy.Name = "Busy"
		Busy.Value = false

		local Stun = Instance.new("NumberValue", Character)
		Stun.Name = "Stun"
		Stun.Value = 0
		
		local DarkBladeSkin = Instance.new("Folder", Player)
		DarkBladeSkin.Name = "DarkBladeSkin"

		local savedEnergy = _G.session[Player].Data.Energy or { Current = 100, Max = 100 }
		local Energy = Instance.new("IntConstrainedValue", Character)
		Energy.Name = "Energy"
		Energy.MaxValue = savedEnergy.Max
		Energy.MinValue = 0
		Energy.Value = savedEnergy.Current
		
		local Rage = Instance.new("IntValue", Character)
		Rage.Name = "Rage"
		Rage.Value = 0

		local Raiding = Instance.new("BoolValue")
		Raiding.Name = "Raiding"
		Raiding.Value = true
		Raiding.Parent = Player.Character

		local Souls = Instance.new("IntValue", Character)
		Souls.Name = "Souls"
		Souls.Value = 9

		local Dodges = Instance.new("IntValue", Character)
		Dodges.Name = "Dodges"
		Dodges.Value = 0

		Character:SetAttribute("BusoEnabled", false)
		Character:SetAttribute("AllCooldown", 0.1)
		Character:SetAttribute("ObservationRange", 9999)
		Character:SetAttribute("SwordCooldown", 0.1)
		Character:SetAttribute("GunCooldown", 0.1)
		Character:SetAttribute("MeleeCooldown", 0.1)
		Character:SetAttribute("FruitCooldown", 0.1)
		Character:SetAttribute("FlashstepCooldown", 0)
		Character:SetAttribute("NoDashing", false)
		Character:SetAttribute("NoTransform", false)
		Character:SetAttribute("SkyjumpBoost", 0)
		Character:SetAttribute("MasterpieceAll", false)
		Character:SetAttribute("MasterpieceSword", false)
		Character:SetAttribute("MasterpieceGun", false)
		Character:SetAttribute("MasterpieceMelee", false)
		Character:SetAttribute("MasterpieceFruit", false)
		Character:SetAttribute("UnbreakableAll", false)
		Player:SetAttribute("PvpDisabled", false)
		Player:SetAttribute("YoruEvolution", true)

		task.delay(2, function()
			Character:AddTag("Ken")
			Character:AddTag("KenUpgrade")
			Character:AddTag("Buso")
			Character:SetAttribute("DashLength", 1)
			Character:SetAttribute("DashLengthAir", 1)
			Character:SetAttribute("DashSpeed", 1)
			Player:SetAttribute("ForceDragonChoiceEast", true)
		end)
		
		local session = _G.session[Player]
		local Data = session.Data

		if ServerStorage:WaitForChild("Items"):FindFirstChild(Data.FightingStyle) then
			ServerStorage:WaitForChild("Items"):FindFirstChild(Data.FightingStyle):Clone().Parent = Player.Backpack
		end

		if Player:WaitForChild("Data").DevilFruit.Value ~= "" or Data.DevilFruit ~= "" then
			if ServerStorage:WaitForChild("Items"):FindFirstChild(Player:WaitForChild("Data").DevilFruit.Value) then
				ServerStorage:WaitForChild("Items"):FindFirstChild(Player:WaitForChild("Data").DevilFruit.Value):Clone().Parent = Player.Backpack
			else
				if ServerStorage:WaitForChild("Items"):FindFirstChild(Data.DevilFruit) then
					ServerStorage:WaitForChild("Items"):FindFirstChild(Data.DevilFruit):Clone().Parent = Player.Backpack
				end
			end
		end

		Root:SetAttribute("DoneSpawning", true)
		Instance.new("Folder", Character).Name = "CharacterReady"
		Character:SetAttribute("CustomScaleApplied", true)
		
		_G.getWrappedPlayer(Player).notify("<Color=Green>Tip: Click 'Commands' button for a list of FREE commands<Color=/>")
		_G.getWrappedPlayer(Player).notify("<Color=Green>Tip: Try redeem 'TheMaster' & 'Kaka' or 'YooY' for free skins!<Color=/>")
		currentLoopId += 1

		local loopId = currentLoopId
		local Rage = Character:WaitForChild("Rage")
		local rageFloat = Rage.Value
		
		task.spawn(function()
			while Character.Parent and loopId == currentLoopId do
				task.wait(1)
				
				rageFloat = math.max(rageFloat, Rage.Value)
				
				if rageFloat < 100 then
					rageFloat += 0.01
					rageFloat = math.min(rageFloat, 100)
					Rage.Value = math.floor(rageFloat)
					
				end
			end
		end)

		local bconnect = Player.Backpack.ChildAdded:Connect(function(Child)
			Child:SetAttribute("OwnerId", Player.UserId)
			task.wait()
			require(game.ReplicatedStorage.SharedComponents.WeaponToolShared)

			if Child:GetAttribute("Level") and _G.session[Player].Data.Mastery[Child.Name] then
				Child:SetAttribute("Level", _G.session[Player].Data.Mastery[Child.Name].Mastery)
				if Child:FindFirstChild("Level") then
					Child.Level.Value = _G.session[Player].Data.Mastery[Child.Name].Mastery
				end
			end
		end)
		Energy.Changed:Connect(function(newValue)
			if _G.session[Player] and _G.session[Player].Data then
				_G.session[Player].Data.Energy.Current = newValue
			end
		end)
		local cconnect = Player.Character.ChildAdded:Connect(function(Child)
			Child:SetAttribute("OwnerId", Player.UserId)
			task.wait()
			require(game.ReplicatedStorage.SharedComponents.WeaponToolShared)

			if Child:GetAttribute("Level") and _G.session[Player].Data.Mastery[Child.Name] then
				Child:SetAttribute("Level", _G.session[Player].Data.Mastery[Child.Name].Mastery)
				if Child:FindFirstChild("Level") then
					Child.Level.Value = _G.session[Player].Data.Mastery[Child.Name].Mastery
				end
			end
		end)
		task.spawn(function()
			while Character and Character.Parent do
				local currentEnergy = Character:FindFirstChild("Energy")
				if not currentEnergy then break end

				local timeSinceUsed = tick() - (_G.session[Player].Data.Energy.LastUsed or 0)

				if timeSinceUsed >= 2 and currentEnergy.Value < currentEnergy.MaxValue then
					currentEnergy.Value = math.min(currentEnergy.Value + (5 * 0.1), currentEnergy.MaxValue)
					_G.session[Player].Data.Energy.Current = currentEnergy.Value
				end

				task.wait(0.1)
			end
		end)

		for _, Item in pairs(_G.session[Player].Data.Inventory) do
			if Item.Equipped == true then
				if Item.Type == "Sword" or Item.Type == "Gun" then
					if ServerStorage:WaitForChild("Items"):FindFirstChild(Item.Name) then
						ServerStorage:WaitForChild("Items"):FindFirstChild(Item.Name):Clone().Parent = Player.Backpack
					elseif Item.Type == "Accessory" then
						if ServerStorage:WaitForChild("Accessories"):FindFirstChild(Item.Name) then
							local Accessory = ServerStorage:WaitForChild("Accessories"):FindFirstChild(Item.Name):Clone()
							Humanoid:AddAccessory(Accessory)
						end
					end
				end
			end
		end

		Humanoid.Died:Connect(function()
			Player:LoadCharacter()
			if cconnect then cconnect:Disconnect() end
			if bconnect then bconnect:Disconnect() end
		end)
	end)
end)

Players.PlayerRemoving:Connect(function(Player)
	if CollectionService:HasTag(Player, "Data") then
		_G.session[Player] = nil
		_G.WrappedPlayers[Player] = nil
		PlayerData[Player.UserId] = nil
		return
	end

	SavePlayerData(Player)

	_G.session[Player] = nil
	_G.WrappedPlayers[Player] = nil
	PlayerData[Player.UserId] = nil
end)

-- Auto-save system
task.spawn(function()
	while task.wait(AutoSaveInterval) do
		for _, player in pairs(Players:GetPlayers()) do
			if _G.session[player] then
				
				SavePlayerData(player)
			end
		end
		print("Auto-save completed for all players")
	end
end)

-- Chest System
for _, ChestSpawn in CollectionService:GetTagged("_ChestTagged") do
	local HitBox = HitboxService.CreateHitbox()
	HitBox.CFrame = ChestSpawn.CFrame
	HitBox.Size = Vector3.new(7.65, 5.5, 4.8)
	HitBox.VisualizerTransparency = 1

	HitBox.Touched:Connect(function(BasePart, Humanoid)
		local Player = Players:GetPlayerFromCharacter(Humanoid.Parent)
		if Player and _G.WrappedPlayers[Player] then
			_G.WrappedPlayers[Player].addBeli(math.random(500, 3000))
			HitBox:Stop()
		end
	end)

	HitBox:Start()

	coroutine.wrap(function()
		while task.wait(2.2) do
			if HitBox then
				HitBox:Stop()
			end
			task.wait(0.1)
			HitBox:Start()
		end
	end)()
end

-- Main Remote Handler
local AllRaces = {"Human", "Fishman", "Mink", "Cyborg", "Skypiea"}

CommF_.OnServerInvoke = function(Player, Instruction, ...)
	local Arguments = {...}

	if Instruction == "SetTeam" then
		Player.Team = game:GetService("Teams")[Arguments[1]]
		Player:LoadCharacter()
		if Player.PlayerGui:FindFirstChild("Main (minimal)") then
			Player.PlayerGui:WaitForChild("Main (minimal)"):Destroy()
		end
		
	elseif Instruction == "ChangeBusoStage" then
		return true

	elseif Instruction == "BlackbeardReward" then
		if Arguments[1] == "Reroll" and Arguments[2] == "1" then
			return true
		end

		if Arguments[1] == "Reroll" and Arguments[2] == "2" then
			local cost = 3000
			if _G.session[Player].Data.Fragments < cost then
				return 0
			end

			local availableRaces = {}
			for _, race in ipairs(AllRaces) do
				table.insert(availableRaces, race)
			end

			
	
			if #availableRaces == 0 then
				return 2
			end

			local newRace = availableRaces[math.random(1, #availableRaces)]
			if type(newRace) == "string" then
				-- _G.WrappedPlayers[Player]:changeRace(newRace)
				return 2
			else
				-- _G.WrappedPlayers[Player]:changeRace("Draco")
				return 2
			end
		end

	elseif Instruction == "SaveData" then
		return SavePlayerData(Player)

	elseif Instruction == "GetInventory" then
		return _G.session[Player].Data.Inventory

	elseif Instruction == "SetLastSpawnPoint" then
		_G.session[Player].Data.LastSpawnPoint = Arguments[1]
		if not table.find(_G.session[Player].Data.UnlockedSpawns, Arguments[1]) then
			table.insert(_G.session[Player].Data.UnlockedSpawns, Arguments[1])
		end

	elseif Instruction == "SetSpawnPoint" then
		_G.session[Player].Data.SpawnPoint = _G.session[Player].Data.LastSpawnPoint
		return 1
		
	elseif Instruction == "AwakeningChanger" then
		if Arguments[1] == "Check" then
			return false
			
		elseif Arguments[1] == "getAwakenedAbilities" then
			local Data = {
				{Key = "Z", Awakened = true, Enabled = true},
				{Key = "X", Awakened = true, Enabled = false},
				{Key = "C", Awakened = true, Enabled = false},
				{Key = "V", Awakened = true, Enabled = false},
				{Key = "F", Awakened = true, Enabled = true},
			}
			
			return Data
		end

	elseif Instruction == "TeleportToSpawn" then
		local Part = Instance.new("Folder")
		Part.Name = "TempSafeZone"
		Part:SetAttribute("Position", Player.Character.HumanoidRootPart.Position)
		Part:SetAttribute("Size", 15)
		Part:SetAttribute("Color", Color3.fromRGB(79, 164, 255))
		Part.Parent = Player.Character

		_G.WrappedPlayers[Player].notify("<Color=Red>Teleporting home to <".._G.session[Player].Data.LastSpawnPoint.."><Color=/>")
		local Second = ReplicatedStorage.Assets.GUI:WaitForChild("PvpBBG"):Clone()
		Second.Parent = Player.Character.HumanoidRootPart

		local StartPosition = Player.Character.HumanoidRootPart.Position
		local MoveDistance = 2
		local canceled = false

		for Number = 5, 1, -1 do
			if (Player.Character.HumanoidRootPart.Position - StartPosition).Magnitude > MoveDistance then
				canceled = true
				break
			end

			Second.TextLabel.Text = "Teleporting in "..Number.."..."
			task.wait(1)
		end

		if canceled then
			Second:Destroy()
			Part:Destroy()
			return false
		end

		Second:Destroy()

		local Place = workspace._WorldOrigin.PlayerSpawns.Pirates:FindFirstChild(_G.session[Player].Data.LastSpawnPoint)
		if Place and Place.Name ~= "Sea" then
			Player.Character:PivotTo(Place:GetChildren()[1].CFrame)
		else
			_G.WrappedPlayers[Player].notify("<Color=Red>You can't Teleport to Sea.<Color=/>")
		end

		Part:Destroy()
		return workspace:GetServerTimeNow() + 25

	elseif Instruction == "CheckCanBuyType" then
		return true

	elseif Instruction == "UpgradeItem" then
		local action = Arguments[1]
		local tool = Player.Character and Player.Character:FindFirstChildOfClass("Tool")
		if not tool then
			tool = Player.Backpack:FindFirstChildOfClass("Tool")
		end

		if not tool or not tool:IsA("Tool") then
			if action == "Check" then
				return nil
			else
				return { Success = false, Message = "Invalid tool." }
			end
		end

		local UpgradeData = {
			Sword = {
				Required = {{ Name = "Hearts", Amount = 10 }},
				Result = "Sword+1",
				ResultStats = { Damage = 50, Speed = 30 }
			},
			Gun = {
				Required = {{ Name = "Hearts", Amount = 15 }},
				Result = "Gun+1",
				ResultStats = { Damage = 30, Range = 50 }
			}
		}

		local toolName = tool.ToolTip
		local data = UpgradeData[toolName]

		if action == "Check" then
			if not data then return nil end
			return {
				Required = data.Required,
				Result = data.Result,
				ResultStats = data.ResultStats
			}

		elseif action == "Upgrade" then
			if not data then
				return { Success = false, Message = "This tool cannot be upgraded." }
			end

			local function hasRequiredItems(player, requiredItems)
				local Inventory = _G.session[player].Data.Inventory
				if not Inventory then return false end
				for _, required in pairs(requiredItems) do
					local found = false
					for _, item in pairs(Inventory) do
						if item.Name == required.Name and item.Count >= required.Amount then
							found = true
							break
						end
					end
					if not found then return false end
				end
				return true
			end

			local function removeRequiredItems(player, requiredItems)
				local Inventory = _G.session[player].Data.Inventory
				if not Inventory then return end
				for _, required in pairs(requiredItems) do
					for _, item in pairs(Inventory) do
						if item.Name == required.Name then
							item.Count = math.max(item.Count - required.Amount, 0)
							CommE:FireClient(player, "ItemChanged", item)
							break
						end
					end
				end
			end

			if not hasRequiredItems(Player, data.Required) then
				return { Success = false, Message = "Not enough materials." }
			end

			removeRequiredItems(Player, data.Required)
			tool.Name = data.Result

			local stats = tool:FindFirstChild("Stats")
			if stats then
				for stat, value in pairs(data.ResultStats) do
					if stats:FindFirstChild(stat) then
						stats[stat].Value = value
					end
				end
			end

			return { Success = true, Message = toolName .. " has been upgraded!" }
		end

		
		
	elseif Instruction == "Team" then
		Player.Team = game:GetService("Teams")[Arguments[1]]
		Player:LoadCharacter()
		return 0
	elseif Instruction == "TravelDressrosa" then
		-- TeleportService:Teleport(134644460575092, Player)
		return "Coming Soon"

	elseif Instruction == "TravelZou" then
		TeleportService:Teleport(93619141626670, Player)
		return "Teleporting..."

	elseif Instruction == "TravelMain" then
		TeleportService:Teleport(134644460575092, Player)
		return "Teleporting..."
	elseif Instruction == "EquipSkin" then
		local SkinName = Arguments[1]
		local SkinInfo = SkinUtil:GetInfoForSkin(SkinName)
		if not SkinInfo then
			return warn("Skin Was Not Found: "..SkinName)
		end
		return true
	elseif Instruction == "SwitchSkin" then
		local function HandleSkinInstruction(Player, Instruction, Arguments)
			assert(Player and Player:IsA("Player"), "Invalid Player")
		local newSkin = Arguments[1]
		local oldSkin = Arguments[2]

		-- Unequip old skin EZ
		local Data = Player:FindFirstChild("Data")
		if Data and Data:FindFirstChild("DevilFruit") then
			local Fruit = Data.DevilFruit
			
			if Fruit:GetAttribute("FruitSkin") == oldSkin then
				Fruit:SetAttribute("FruitSkin", nil)
			end
		end

		-- Equip new skin EZ
		return HandleSkinInstruction(Player, "EquipSkin", {newSkin})
	end
	elseif Instruction == "ChangeSkin" then
		-- Arguments[1] = SkinName, Arguments[2] = Character (optional)
		local skinName = Arguments[1]
		local char = Arguments[2] or Player.Character
		if not char then return warn("No character to change skin on") end

		local Data = Player:FindFirstChild("Data")
		if Data and Data:FindFirstChild("DevilFruit") then
			local Fruit = Data.DevilFruit
			local modulescript = game.ReplicatedStorage:FindFirstChild("SkinnedRigs")
			if modulescript then
				SkinUtil.ApplySkinToRig(skinName, char, modulescript)
			end
		end

		local skinInfo = SkinUtil:GetInfoForSkin(skinName)
		if skinInfo and skinInfo.VFXColor then
			local vfxFolder = char:FindFirstChild(skinInfo.VFXFolder or "DragonFruitVFXColor")
			if vfxFolder then
				for attrName, color in pairs(skinInfo.VFXColor) do
					if vfxFolder:GetAttribute(attrName) ~= nil then
						vfxFolder:SetAttribute(attrName, color)
					end
				end
			end
		end

		return 0
	elseif Instruction == "OpenPotions" then
		if Arguments[1] == "Health Potion" then
			local healthGain = 50
			local maxHealthGain = 50

			pcall(function()
				require(ReplicatedStorage.Util.Anims):Get("OpenPotions"):Play()
			end)

			Player.Character.Humanoid.MaxHealth = Player.Character.Humanoid.MaxHealth + maxHealthGain
			Player.Character.Humanoid.Health = math.min(Player.Character.Humanoid.Health + healthGain, Player.Character.Humanoid.MaxHealth)

			local function createEffect(hrp)
				if not ReplicatedStorage:FindFirstChild("HealthVFX") then return end
				local VFX = ReplicatedStorage:WaitForChild("HealthVFX"):WaitForChild("Arrow"):Clone()
				local Second = ReplicatedStorage:WaitForChild("HealthVFX"):WaitForChild("Main-01"):Clone()
				local Highlight = ReplicatedStorage:WaitForChild("HealthVFX"):WaitForChild("Highlight"):Clone()
				local torso = hrp.Parent:FindFirstChild("UpperTorso")
				if not torso then return end
				Highlight.Parent = hrp.Parent
				game:GetService("Debris"):AddItem(Highlight, 1)
				VFX.Parent = torso
				Second.Parent = torso
				task.delay(5, function()
					if VFX then VFX:Destroy() end
					if Second then Second:Destroy() end
				end)
			end

			pcall(function()
				createEffect(Player.Character.HumanoidRootPart)
			end)
			return 1
		end

	elseif Instruction == "GetDmgCounterSetting" then
		return _G.session[Player].Data.DamageCounter

	elseif Instruction == "ToggleCounter" then
		_G.session[Player].Data.DamageCounter = Arguments[1]
		return true

	elseif Instruction == "RaidsNpc" then
		if Arguments[1] == "Check" then
			local Level = _G.session[Player].Data.Level
			local PlayerRaids = {
				[Player.UserId] = {
					Flame = true, Ice = true, Quake = true, Light = true,
					Dark = true, Spider = true, Rumble = true, Magma = true,
					Buddha = true, Sand = true,
				},
			}
			if Level < 1000 then
				return 0
			else
				return Level, PlayerRaids[Player.UserId]
			end

		elseif Arguments[1] == "Select" then
			local FruitName = Arguments[2]
			if _G.session[Player].Data.Level < 1100 then
				return 0
			end

			if not PlayerData[Player.UserId] then
				PlayerData[Player.UserId] = { LastPurchase = 0 }
			end
			local data = PlayerData[Player.UserId]

			local now = os.time()
			if now - data.LastPurchase < 2 * 60 * 60 then
				return "You must wait before buying another microchip!"
			end

			local hasFruit = Player.Character:FindFirstChild(FruitName)
			if hasFruit then
				data.LastPurchase = now
				return 1
			elseif _G.session[Player].Data.Beli >= 1000 then
				_G.session[Player].Data.Beli = _G.session[Player].Data.Beli - 1000
				Player:FindFirstChild("Data").Beli.Value = _G.session[Player].Data.Beli
				data.LastPurchase = now
				return 1
			else
				return "You don't have enough Beli!"
			end
		end

	elseif Instruction == "buyRobuxShop" then
		local ShopData = Arguments[1]
		local StorageName = ShopData.StorageName

		pcall(function()
			local ProductData = require(ReplicatedStorage.Shop.ProductData)
			if ProductData[StorageName] and ProductData[StorageName].assetId then
				_G.getWrappedPlayer(Player).notify("<Color=Red>All products are disabled.<Color=/>")
			else
				_G.getWrappedPlayer(Player).notify("<Color=Red>Invalid product.<Color=/>")
			end
		end)

	elseif Instruction == "EnablePvp" then
		local Second = ReplicatedStorage.Assets.GUI:WaitForChild("PvpBBG"):Clone()
		Second.Parent = Player.Character.HumanoidRootPart

		for Number = 5, 1, -1 do
			Second.TextLabel.Text = "Enabling PVP in "..Number.."..."
			task.wait(1)
		end

		Second:Destroy()
		Player:SetAttribute("PvpDisabled", false)
		return true

	elseif Instruction == "GetFruits" then
		local Fruits = {}
		for i, v in pairs(_G.session[Player].Data.RobuxFruits) do
			table.insert(Fruits, {
				HasPermanent = v,
				OnSale = true,
				Name = i
			})
		end

		TableUtil.deepFreeze(Fruits)
		return Fruits

	elseif Instruction == "RemoveFruit" then
		pcall(function()
			if require(ReplicatedStorage.Util.IsTransformed)(Player.Character, true, true) then
				return 4
			end
		end)

		local money = Player.Data:FindFirstChild("Beli")
		local backpack = Player:FindFirstChild("Backpack")
		local removeCost = 50000

		local tool = backpack:FindFirstChildOfClass("Tool")
		if not tool or tool.ToolTip ~= "Blox Fruit" then
			return 2
		end

		if not money or money.Value < removeCost then
			return 0
		end

		tool:Destroy()
		money.Value = money.Value - removeCost
		_G.session[Player].Data.Beli = _G.session[Player].Data.Beli - removeCost
		return 1

	elseif Instruction == "SwitchFruit" then
		if not _G.session[Player].Data.RobuxFruits[Arguments[1]] then return false end
		if not ServerStorage:WaitForChild("Items"):FindFirstChild(Arguments[1]) then return false end
		_G.getWrappedPlayer(Player).changeDevilFruit(Arguments[1], Arguments[2])
		return true

	elseif Instruction == "DragonType" then
		return "West"

	elseif Instruction == "Teleport" then
		if Arguments[1] == "Ghost" then
			if Player.Character:FindFirstChild("Kitsune-Kitsune") and Player.Character:FindFirstChild("Kitsune-Kitsune").ToolTip ~= "Blox Fruit" or Player:WaitForChild("Backpack"):FindFirstChild("Kitsune-Kitsune") and Player:WaitForChild("Backpack"):FindFirstChild("Kitsune-Kitsune").ToolTip ~= "Blox Fruit" then
			-- Player.Character:MoveTo(Vector3.new(-1656.814, 4788.329, 195.58))
			Player.Character:MoveTo(Vector3.new(76302, 4.458, -35492))
			Player.Character.Raiding.Value = true
				return 1
			else
				return 2
			end
		end

	elseif Instruction == "getInventory" then
		return _G.session[Player].Data.Inventory

	elseif Instruction == "EquipAccessory" then
		local Accessory = AccessoryFolder:FindFirstChild(Arguments[1])
		if Accessory and Accessory:IsA("Accessory") then
			local ClonedAccessory = Accessory:Clone()
			Player.Character.Humanoid:AddAccessory(ClonedAccessory)
		elseif not Accessory then
			warn("Not Found Accessory: "..Arguments[1])
		end

	elseif Instruction == "Cousin" then
		if Arguments[1] == "Check" then
			return _G.session[Player].Data.Beli, _G.session[Player].Data.Level, 0
		elseif Arguments[1] == "CheckCanBuyType"  then
			return true
		
		elseif Arguments[1] == "Buy" then
			if not ServerStorage:FindFirstChild("Fruits") then return 0 end
			local fruits = ServerStorage:WaitForChild("Fruits"):GetChildren()
			if #fruits == 0 then return 0 end

			local raffle = { Name = "FruitGacha", Entries = {} }
			local Winner = { Data = {} , Instance = {}, Awards = {} }

			local FruitRarity = require(ServerScriptService.Rarities.FruitRarities)
			local RarityData = {
				[0] = { Name = "Common", Color = Color3.fromRGB(179, 179, 179), Value = 0 },
				[1] = { Name = "Uncommon", Color = Color3.fromRGB(92, 140, 211), Value = 1 },
				[2] = { Name = "Rare", Color = Color3.fromRGB(140, 82, 255), Value = 2 },
				[3] = { Name = "Legendary", Color3.fromRGB(213, 43, 228), Value = 3 },
				[4] = { Name = "Mythical", Color = Color3.fromRGB(238, 47, 50), Value = 4 },
				[5] = { Name = "Premium", Color = Color3.fromRGB(221, 188, 0), Value = 5 },
			}

			for _, fruit in ipairs(fruits) do
				local baseName = fruit.Name:split("-")[1]
				local StorageName = fruit.Name
				local rarityValue = FruitRarity[StorageName] and FruitRarity[StorageName].rarity or 3

				raffle.Entries[StorageName] = {
					DisplayName = baseName,
					StorageName = StorageName,
					Awards = {
						Name = Winner.Data.DisplayName,
						Amount = 1,
						ItemType = "Item",
					},
					Rarity = tostring(FruitRarity[StorageName].rarity)
				}
			end

			local winnerFruit = fruits[math.random(1, #fruits)]
			local baseName = winnerFruit.Name:split("-")[1]
			local WinnerStorageName = winnerFruit.Name
			local rarityValue = FruitRarity[WinnerStorageName] and FruitRarity[WinnerStorageName].rarity or 3

			Winner.Data = {
				DisplayName = baseName,
				StorageName = WinnerStorageName,
				Rarity = tostring(FruitRarity[WinnerStorageName].rarity)
			}
			
			Winner.Awards = {
				Name = Winner.Data.DisplayName,
				Amount = 1,
				ItemType = "Item",
			}

			local Folder = Player.PlayerGui:FindFirstChild("__ReplicatedFruits")
			if not Folder then
				Folder = Instance.new("Folder")
				Folder.Name = "__ReplicatedFruits"
				Folder.Parent = Player.PlayerGui
			else
				Folder:ClearAllChildren()
			end

			local ReplicatedFruits = winnerFruit:Clone()
			ReplicatedFruits.Parent = Folder
			Winner.Instance = ReplicatedFruits

			Net:RemoteEvent("SpinGacha"):FireClient(Player, {
				Raffle = raffle,
				Winner = Winner,
				Instance = ReplicatedFruits,
				DisplayLineItems = {
					Item = Winner.Data.StorageName,
					Awards = {
						Name = Winner.Data.DisplayName,
						Amount = 1,
						ItemType = "Item",
					},
					DisplayName = baseName,
					Rarity = tostring(FruitRarity[Winner.Data.StorageName].rarity)
				}
			})

			local clone = winnerFruit:Clone()
			clone.CanBeDropped = true
			clone.Name = baseName .. " Fruit"
			clone.Parent = Player.Backpack

			return 1
		elseif Arguments[1] == "BuySkin" then
			if not ServerStorage:FindFirstChild("Skins") then return 0 end
			local fruits = ServerStorage:WaitForChild("Skins"):GetChildren()
			if #fruits == 0 then return 0 end

			local raffle = { Name = "SkinGacha", Entries = {} }
			local Winner = { Data = {} , Instance = {}, Awards = {} }

			for _, fruit in ipairs(fruits) do
				local baseName = fruit.Name:split("-")[1]
				local StorageName = fruit.Name

				raffle.Entries[StorageName] = {
					DisplayName = baseName,
					StorageName = StorageName,
					Awards = {
						Name = Winner.Data.DisplayName,
						Amount = 1,
						ItemType = "Item",
					},
					Rarity = 4
				}
			end

			local winnerFruit = fruits[math.random(1, #fruits)]
			local baseName = winnerFruit.Name:split("-")[1]
			local WinnerStorageName = winnerFruit.Name

			Winner.Data = {
				DisplayName = baseName,
				StorageName = WinnerStorageName,
				Rarity = 4
			}

			Winner.Awards = {
				Name = Winner.Data.DisplayName,
				Amount = 1,
				ItemType = "Item",
			}

			local Folder = Player.PlayerGui:FindFirstChild("__ReplicatedFruits")
			if not Folder then
				Folder = Instance.new("Folder")
				Folder.Name = "__ReplicatedFruits"
				Folder.Parent = Player.PlayerGui
			else
				Folder:ClearAllChildren()
			end

			local ReplicatedFruits = winnerFruit:Clone()
			ReplicatedFruits.Parent = Folder
			Winner.Instance = ReplicatedFruits

			Net:RemoteEvent("SpinGacha"):FireClient(Player, {
				Raffle = raffle,
				Winner = Winner,
				Instance = ReplicatedFruits,
				DisplayLineItems = {
					Item = Winner.Data.StorageName,
					Awards = {
						Name = Winner.Data.DisplayName,
						Amount = 1,
						ItemType = "Item",
					},
					DisplayName = baseName,
					Rarity = 4
				}
			})

			local clone = winnerFruit:Clone()
			clone.CanBeDropped = true
			clone.Parent = Player.Backpack

			return 1
		end

	elseif Instruction == "StoreFruit" then
		local fruitName = Arguments[1]
		local char = Player.Character or Player.CharacterAdded:Wait()
		local backpack = Player:FindFirstChildOfClass("Backpack")

		if not Player:FindFirstChild("StoredFruits") then
			local folder = Instance.new("Folder")
			folder.Name = "StoredFruits"
			folder.Parent = Player
		end

		local storedFruits = Player:FindFirstChild("StoredFruits")
		local fruitValue = storedFruits:FindFirstChild(fruitName)
		if not fruitValue then
			fruitValue = Instance.new("IntValue")
			fruitValue.Name = fruitName
			fruitValue.Value = 1
			fruitValue.Parent = storedFruits
		else
			fruitValue.Value = fruitValue.Value + 1
		end

		local fruitModel = char:FindFirstChild(fruitName:split("-")[1] .. " Fruit")
		if fruitModel then
			fruitModel:Destroy()
		end

		if backpack then
			local tool = backpack:FindFirstChild(fruitName:split("-")[1] .. " Fruit")
			if tool then
				tool:Destroy()
			end
		end
		
		_G.getWrappedPlayer(Player).awardBloxFruitItem(fruitName, 1, false)
		_G.getWrappedPlayer(Player).notify("Blox Fruit stored.")
		return true

	elseif Instruction == "LoadItem" then
		local char = Player.Character or Player.CharacterAdded:Wait()
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		if not humanoid then return false end

		local ItemEquipped = false
		local Accessory = AccessoryFolder:FindFirstChild(Arguments[1])
		if Accessory and Accessory:IsA("Accessory") then
			for _, v in ipairs(char:GetChildren()) do
				if v:IsA("Accessory") and v.Name == Accessory.Name then
					v:Destroy()
				end
			end
			
			humanoid:AddAccessory(Accessory:Clone())
			ItemEquipped = true
		elseif Accessory and Accessory:IsA("Model") then
			local ServerStorage = game:GetService("ServerStorage"):WaitForChild("Accessories")

			local function weldModelToCharacter(character, model)
				model = model:Clone()
				model.Parent = character

				local torso =
					character:FindFirstChild("UpperTorso")
					or character:FindFirstChild("Torso")
				if not torso then
					model:Destroy()
					return
				end

				local root = model:FindFirstChild("RootPart")
				if not root or not root:IsA("BasePart") then
					warn("Model missing RootPart:", model.Name)
					model:Destroy()
					return
				end

				for _, obj in ipairs(model:GetDescendants()) do
					if obj:IsA("BasePart") then
						obj.Anchored = false
						obj.CanCollide = false
						obj.Massless = true
					end
				end

				root.CFrame = torso.CFrame
				local weld = Instance.new("WeldConstraint")
				weld.Part0 = root
				weld.Part1 = torso
				weld.Parent = root
			end

			weldModelToCharacter(Player.Character, Accessory)
			ItemEquipped = true
		else
			local tool = ServerStorage.Items:FindFirstChild(Arguments[1])
			if tool and tool:IsA("Tool") then
				local function deleteByType(typ)
					humanoid:UnequipTools()
					if Player:FindFirstChild("Backpack") then
						for _, v in Player.Backpack:GetChildren() do
							if v:IsA('Tool') and v.ToolTip and v.ToolTip == typ then
								v:Destroy()
							end
						end
					end
					for _, v in char:GetChildren() do
						if v:IsA('Tool') and v.ToolTip and v.ToolTip == typ then
							v:Destroy()
						end
					end
				end

				if tool.ToolTip then
					deleteByType(tool.ToolTip)
				end

				tool:Clone().Parent = Player.Backpack
				ItemEquipped = true
			else
				CommE:FireClient(Player, "Notify", "<Color=Red>Not found <"..Arguments[1].."> Item.<Color=/>")
				CommE:FireClient(Player, "Notify", "<Color=Red>This item is Coming Soon!<Color=/>")
				return false
			end
		end

		if ItemEquipped then
			local item = SearchInsideInventoryOfPlayer(Player, Arguments[1])
			if item then
				for _, otherItem in ipairs(_G.session[Player].Data.Inventory) do
					if otherItem.Equipped and otherItem.Type == item.Type then
						otherItem.Equipped = false
						CommE:FireClient(Player, "ItemUnequipped", otherItem.Name)
						CommE:FireClient(Player, "ItemChanged", otherItem)
					end
				end

				item.Equipped = true
				CommE:FireClient(Player, "Notify", "Equipped <Color=Green><"..Arguments[1].."><Color=/>")
				CommE:FireClient(Player, "ItemChanged", item)
			end
		end

		return true

	elseif Instruction == "Accessories" then
		local Accessories = ServerStorage.Accessories:FindFirstChild(Arguments[1])
		local char = Player.Character or Player.CharacterAdded:Wait()

		if Accessories then
			char.Humanoid:AddAccessory(Accessories:Clone())
			local Item = SearchInsideInventoryOfPlayer(Player, Arguments[1])
			if Item then
				Item.Equipped = true
				CommE:FireClient(Player, "ItemChanged", Item)
			end
		end
		return true

	elseif Instruction == "StoreItem" then
		local itemName = Arguments[1]
		local char = Player.Character or Player.CharacterAdded:Wait()
		local humanoid = char:FindFirstChildOfClass("Humanoid")

		local Accessory = AccessoryFolder and AccessoryFolder:FindFirstChild(itemName)
		if Accessory and Accessory:IsA("Accessory") then
			local existingAccessory = char:FindFirstChild(Accessory.Name)
			if existingAccessory then
				existingAccessory:Destroy()
			end
		else
			pcall(function()
				local toolData = require(ReplicatedStorage.Modules.CombatUtil)
				local weaponData = toolData:GetWeaponData(toolData:GetPureWeaponName(itemName))
				local weaponType = weaponData and weaponData.WeaponType

				if weaponType then
					humanoid:UnequipTools()
					for _, v in Player.Backpack:GetChildren() do
						if v:IsA("Tool") and v.ToolTip and v.ToolTip == weaponType then
							v:Destroy()
						end
					end
					for _, v in char:GetChildren() do
						if v:IsA("Tool") and v.ToolTip and v.ToolTip == weaponType then
							v:Destroy()
						end
					end
				end
			end)
		end

		local item = SearchInsideInventoryOfPlayer(Player, itemName)
		if item then
			item.Equipped = false
			CommE:FireClient(Player, "ItemChanged", item)
		end

		return true

	elseif Instruction == "RedeemStoredGamepass" then
		local itemName = Arguments[1]
		local session = _G.session[Player]
		if not session or not session.Data then return false end

		local inventory = session.Data.Inventory

		for i, item in ipairs(inventory) do
			if item.Name == itemName and item.Type == "Premium" then

				table.remove(inventory, i)

				local boxData = Instance.new("Folder")
				boxData.Name = "__BoxData"

				boxData:SetAttribute("Main", "Kitsune-Kitsune")
				boxData:SetAttribute("Beli", 150)
				boxData:SetAttribute("Fragments", 210)
				boxData.Parent = Player
				
				_G.WrappedPlayers[Player].addBeli(150)
				_G.WrappedPlayers[Player].addFragments(210)
				ServerStorage:WaitForChild("Fruits")["Kitsune-Kitsune"]:Clone().Parent = Player.Backpack
				task.delay(60, function()
					if boxData then
						boxData:Destroy()
					end
				end)

				return true, "Kitsune-Kitsune"
			end
		end

		return false

	elseif Instruction == "LoadFruit" then
		local fruitName = Arguments[1]
		local tool = ServerStorage.Fruits:FindFirstChild(fruitName)
		local char = Player.Character or Player.CharacterAdded:Wait()

		local function DeleteByType(typ)
			char:FindFirstChildOfClass("Humanoid"):UnequipTools()
			for i, v in Player.Backpack:GetChildren() do
				if v:IsA('Tool') and v.ToolTip and v.ToolTip == typ then
					v:Destroy()
				end
			end
			for i, v in char:GetChildren() do
				if v:IsA('Tool') and v.ToolTip and v.ToolTip == typ then
					v:Destroy()
				end
			end
		end

		if tool and tool:IsA('Tool') then
			if tool.ToolTip then
				DeleteByType(tool.ToolTip)
				tool:Clone().Parent = Player.Backpack
			end
		end

		CommE:FireClient(Player, "Notify", "Fruit added to Backpack")
		local item = SearchInsideInventoryOfPlayer(Player, fruitName)
		if item then
			if item.Count == 1 then
				CommE:FireClient(Player, "ItemRemoved", item)
				local inv = _G.session[Player].Data.Inventory
				for i, v in ipairs(inv) do
					if v == item then
						table.remove(inv, i)
						break
					end
				end
			elseif item.Count > 1 then
				item.Count = item.Count - 1
				CommE:FireClient(Player, "ItemChanged", item)
			end
		end
		return true

	elseif Instruction == "LoadPotion" then
		local Position = ServerStorage.Potions and ServerStorage.Potions:FindFirstChild(Arguments[1]) or (ServerStorage.Potions and ServerStorage.Potions:FindFirstChild("Health Potion"))
		local char = Player.Character or Player.CharacterAdded:Wait()

		if Position then
			Position:Clone().Parent = Player.Backpack
		end

		CommE:FireClient(Player, "Notify", "Potion added to Backpack")

		local item = SearchInsideInventoryOfPlayer(Player, Arguments[1])
		if item then
			if item.Count == 1 then
				CommE:FireClient(Player, "ItemRemoved", item)
				local inv = _G.session[Player].Data.Inventory
				for i, v in ipairs(inv) do
					if v == item then
						table.remove(inv, i)
						break
					end
				end
			elseif item.Count > 1 then
				item.Count = item.Count - 1
				CommE:FireClient(Player, "ItemChanged", item)
			end
		end

		return true

	elseif Instruction == "GetUnlockables" then
		return {
			FlamingoAccess = true,
			GhostShip = _G.session[Player].Data.Level
		}

	elseif Instruction == "Buso" then
		local char = Player.Character
		if not char then return end

		local hasBuso = char:FindFirstChild("HasBuso")

		if char:GetAttribute("BusoEnabled") then
			hasBuso:Destroy()
			char:SetAttribute("BusoEnabled", false)
			return
		end

		local marker = Instance.new("BoolValue")
		marker.Name = "HasBuso"
		marker.Value = true
		marker.Parent = char

		local finalColor = Color3.fromRGB(255, 149, 0)
		if Player:FindFirstChild("Data") 
			and Player.Data:FindFirstChild("BusoColor") 
			and tonumber(Player.Data.BusoColor.Value) 
		then
			finalColor = Color3.fromRGB(Player.Data.BusoColor.Value)
		end

		Effect.new("ActivateAura"):replicate({
			Character = char,
			Color = finalColor,
			Color2 = finalColor,
			Rainbow = false
		})

		char:SetAttribute("BusoEnabled", true)
	elseif Instruction == "BuyHaki" then
		local haki = Arguments[1]
		local char = Player.Character or Player.CharacterAdded:Wait()
		char:AddTag(haki)
		return 1

	elseif Instruction == "StartQuest" then
		return _G.getWrappedPlayer(Player).startQuest(Arguments[1], Arguments[2])

	elseif Instruction == "AbandonQuest" then
		_G.getWrappedPlayer(Player).abandonCurrentQuest()
		return true

	elseif Instruction == "BuyItem" then
		local item = Arguments[1]
		_G.getWrappedPlayer(Player).awardEtcItem(item, 1)
		return 1

	elseif Instruction == "Compliment" then
		_G.getWrappedPlayer(Player).awardEtcItem("Hearts", math.random(500, 10000))
		return true

	elseif Instruction == "AddPoint" then
		if Player:WaitForChild("Data").Points.Value < Arguments[2] then
			return
		end
		if Player:WaitForChild("Data").Stats[Arguments[1]].Level.Value >= 2800 then
			Player:WaitForChild("Data").Stats[Arguments[1]].Level.Value = 2800
			return
		end
		if Player:WaitForChild("Data").Points.Value <= 0 then
			Player:WaitForChild("Data").Points.Value = 0
			return
		end

		Player:WaitForChild("Data").Stats[Arguments[1]].Level.Value = Player:WaitForChild("Data").Stats[Arguments[1]].Level.Value + Arguments[2]
		Player:WaitForChild("Data").Points.Value = Player:WaitForChild("Data").Points.Value - Arguments[2]
		return true

	elseif Instruction == "requestEntrance" then
		local char = Player.Character
		if not char then return end
		local hrp = char:FindFirstChild("HumanoidRootPart")
		local humanoid = char:FindFirstChild("Humanoid")
		local busy = char:FindFirstChild("Busy")

		if not hrp or not humanoid or not busy then return end
		if busy.Value == true or humanoid.Sit == true then return end

		if CollectionService:HasTag(Player, "Teleporting") then return end
		CollectionService:AddTag(Player, "Teleporting")

		hrp.Position = Arguments[1]
		wait(0.1)
		CollectionService:RemoveTag(Player, "Teleporting")
		return true

	elseif Instruction == "TravelDressrosa" then
		return "Teleporting..."

	elseif Instruction == "TravelMain" then
		return "Teleporting..."

	elseif Instruction == "CreateCrew" then
		local crewName = Arguments[1]
		if _G.session[Player].Data.CrewId then
			_G.getWrappedPlayer(Player).notify("You're already in a crew!")
			return false
		end
		local crew = CreateCrew(Player, crewName)
		_G.getWrappedPlayer(Player).notify("Crew created: " .. crewName)
		return crew

	elseif Instruction == "GetCrew" then
		local crewId = _G.session[Player].Data.CrewId
		if crewId then
			return GetCrew(crewId)
		end
		return nil

	elseif Instruction == "InviteToCrew" then
		local targetPlayerName = Arguments[1]
		local targetPlayer = Players:FindFirstChild(targetPlayerName)
		if not targetPlayer then
			_G.getWrappedPlayer(Player).notify("Player not found!")
			return false
		end
		local crewId = _G.session[Player].Data.CrewId
		if not crewId then
			_G.getWrappedPlayer(Player).notify("You're not in a crew!")
			return false
		end
		return InviteToCrew(crewId, targetPlayer)

	elseif Instruction == "JoinCrew" then
		local crewId = Arguments[1]
		if _G.session[Player].Data.CrewId then
			_G.getWrappedPlayer(Player).notify("You're already in a crew!")
			return false
		end
		local success = JoinCrew(Player, crewId)
		if success then
			_G.getWrappedPlayer(Player).notify("You joined the crew!")
		end
		return success

	elseif Instruction == "LeaveCrew" then
		local success = LeaveCrew(Player)
		if success then
			_G.getWrappedPlayer(Player).notify("You left the crew.")
		end
		return success

	elseif Instruction == "GetCrewInvites" then
		return _G.session[Player].Data.CrewInvites or {}
	end
end

-- Fighting Style Remote
Style.OnServerInvoke = function(plr, request, isCheck)
	local data = _G.session[plr].Data

	if fightingStyles[request:gsub("Buy", "")] then
		local styleName = request:gsub("Buy", "")
		local styleInfo = fightingStyles[styleName]

		if isCheck then
			if data.FightingStyle == styleName then
				return 1
			elseif not hasEnoughMoney(plr, styleInfo) then
				return 0
			else
				return nil
			end
		end

		if data.FightingStyle == styleName then
			return 2
		end

		if not hasEnoughMoney(plr, styleInfo) then
			return 0
		end

		if not ServerStorage.Items:FindFirstChild(styleInfo.DisplayName) then
			return 0
		end

		data.Beli = data.Beli - styleInfo.Price
		data.Fragments = data.Fragments - styleInfo.Fragment
		_G.WrappedPlayers[plr].changeFightingStyle(styleInfo.DisplayName, styleInfo.Price, styleInfo.Fragment)

		return 1
	end

	return nil
end

--- Skin NetWork By Kaka
ReplicatedStorage.Modules.Net["RF/FruitCustomizerRF"].OnServerInvoke = function(player, data)
	local Context
	local Arguments = {}

	if typeof(data) == "table" then
		Context = data.Context
		Arguments = data
	else
		Context = data
		Arguments = {}	
	end

 	if not _G.session[player] or not _G.session[player].Data then
		warn("No session for player:", player.Name)
		return nil
	end

	local Data = _G.session[player].Data

 	if not Data.FruitCustomizer then
		Data.FruitCustomizer = { Skins = { Owned = {}, Equipped = nil } }
	end
	if not Data.FruitCustomizer.Skins then
		Data.FruitCustomizer.Skins = { Owned = {}, Equipped = nil }
	end
	if not Data.FruitCustomizer.Skins.Owned then
		Data.FruitCustomizer.Skins.Owned = {}
	end
	if not Data.OwnedColors then
		Data.OwnedColors = {}
	end

	if Context == "GetSkinsInventory" then
		local inventory = {}

 		if FruitSkins and FruitSkins.Ungrouped then
			for storageName, skinInfo in pairs(FruitSkins.Ungrouped) do
				local isOwned = Data.FruitCustomizer.Skins.Owned[storageName] == true
				local isEquipped = Data.FruitCustomizer.Skins.Equipped == storageName

				table.insert(inventory, {
					StorageName = storageName,
					Type = "FruitSkin",
					Rarity = skinInfo.Rarity or 0,
					Count = isOwned and 1 or 0,
					Equipped = isEquipped,
					DisplayName = skinInfo.DisplayName or storageName,
					IsNew = false
				})
			end
		end

 		if AuraSkins then
			for storageName, skinInfo in pairs(AuraSkins) do
				local isOwned = Data.OwnedColors[storageName] == true
				local isEquipped = Data.EquippedColor == storageName

				table.insert(inventory, {
					StorageName = storageName,
					Type = "AuraSkin",
					Rarity = skinInfo.Rarity or 0,
					Count = isOwned and 1 or 0,
					Equipped = isEquipped,
					DisplayName = skinInfo.DisplayName or storageName,
					IsNew = false
				})
			end
		end

		print("‚úÖ Sending", #inventory, "skins to", player.Name)
		return inventory

	elseif Context == "Switch" or Context == "Equip" then
		local storageName = Arguments.StorageName
		local skinType = Arguments.Type

		if skinType == "FruitSkin" then
 			local oldEquipped = Data.FruitCustomizer.Skins.Equipped

 			if storageName and not Data.FruitCustomizer.Skins.Owned[storageName] then
				warn("‚ö†Ô∏è Player", player.Name, "doesn't own skin:", storageName)
				return false
			end

 			if not storageName then
				Data.FruitCustomizer.Skins.Equipped = nil

 				local playerDataFolder = player:FindFirstChild("Data")
				if playerDataFolder then
					local devilFruit = playerDataFolder:FindFirstChild("DevilFruit")
					if devilFruit then
						devilFruit:SetAttribute("FruitSkin", nil)
					end
				end

 				if oldEquipped then
					Net:RemoteEvent("SkinsNetworkRE"):FireClient(player, "SkinChanged", {
						StorageName = oldEquipped,
						Type = "FruitSkin",
						Count = 1,
						Equipped = false
					})
				end

				return true
			end

 			Data.FruitCustomizer.Skins.Equipped = storageName

 			local playerDataFolder = player:FindFirstChild("Data")
			if playerDataFolder then
				local devilFruit = playerDataFolder:FindFirstChild("DevilFruit")
				if devilFruit then
					devilFruit:SetAttribute("FruitSkin", storageName)
				end
			end

 			if oldEquipped and oldEquipped ~= storageName then
				Net:RemoteEvent("SkinsNetworkRE"):FireClient(player, "SkinChanged", {
					StorageName = oldEquipped,
					Type = "FruitSkin",
					Count = 1,
					Equipped = false
				})
			end

 			Net:RemoteEvent("SkinsNetworkRE"):FireClient(player, "SkinChanged", {
				StorageName = storageName,
				Type = "FruitSkin",
				Count = 1,
				Equipped = true
			})

 			local skinInfo = FruitSkins.Ungrouped[storageName]
			local displayName = skinInfo and skinInfo.DisplayName or storageName
			CommE:FireClient(player, "Notify", ("Equipped <Color=Green><%s>!<Color=/>"):format(displayName))

			print("‚úÖ", player.Name, "switched to skin:", storageName)
			return true

		elseif skinType == "AuraSkin" then
 			local oldEquipped = Data.EquippedColor

 			if storageName and not Data.OwnedColors[storageName] then
				warn("‚ö†Ô∏è Player", player.Name, "doesn't own aura:", storageName)
				return false
			end

 			if not storageName then
				Data.EquippedColor = nil

 				if oldEquipped then
					Net:RemoteEvent("SkinsNetworkRE"):FireClient(player, "SkinChanged", {
						StorageName = oldEquipped,
						Type = "AuraSkin",
						Count = 1,
						Equipped = false
					})
				end

				return true
			end

 			Data.EquippedColor = storageName

 			if oldEquipped and oldEquipped ~= storageName then
				Net:RemoteEvent("SkinsNetworkRE"):FireClient(player, "SkinChanged", {
					StorageName = oldEquipped,
					Type = "AuraSkin",
					Count = 1,
					Equipped = false
				})
			end

 			Net:RemoteEvent("SkinsNetworkRE"):FireClient(player, "SkinChanged", {
				StorageName = storageName,
				Type = "AuraSkin",
				Count = 1,
				Equipped = true
			})

 			local skinInfo = AuraSkins[storageName]
			local displayName = skinInfo and skinInfo.DisplayName or storageName
			CommE:FireClient(player, "Notify", ("Equipped <Color=Green><%s> Aura!<Color=/>"):format(displayName))

			print("‚úÖ", player.Name, "switched to aura:", storageName)
			return true
		end

		return false
	end

	return nil
end

-- Get Game Version
ReplicatedStorage.Modules.Net["RF/GetGameVersion"].OnServerInvoke = function(Player)
	return "Divine Fruits"
end

ReplicatedStorage.Modules.Net["RF/Hitbox"].OnServerInvoke = function(Player)
	require(game.ServerScriptService.Hitbox):CreateHitbox({
		Character = Player.Character,
		Damage = 1600,
		Size = Vector3.new(20,15,80),
		Offset = CFrame.new(0, 0, -30),
		Distance = 50,
		FollowHRP = true,
		Time = 0,
		HitboxLifetime = .65,
		TweenEnabled = false,
		StopOnCollision = false,
		Stun = {
			Enabled = false,
			Duration = 3.1,
		},
		Knockback = {
			Enabled = true,
			Force = Vector3.new(0, 0, -200),
			Duration = .3,
		},
		OnHit = function(model, humanoid) end,
	})

	return true
end

CommE.OnServerEvent:Connect(function(Player, Instruction, ...)
	local Args = {...}
	if Instruction == "Dodge" then
		Player.Character.Energy.Value -= 30
	end
end)

-- Get Fruit Data
Remotes.GetFruitData.OnServerInvoke = function()
	local FruitData = {}
	local ItemsFolder = ServerStorage:WaitForChild('Items')

	for _, v in ItemsFolder:GetChildren() do
		if v:IsA("Tool") and v.ToolTip == "Blox Fruit" then
			local Data = v:FindFirstChild("Data")
			if Data and Data:IsA('ModuleScript') then
				local success, Required = pcall(function()
					return require(Data)
				end)
				if success then
					Required = TableUtil.deepCopy(Required)
					TableUtil.deepFreeze(Required)
					FruitData[v.Name] = Required
				end
			end
		end
	end

	table.freeze(FruitData)
	return FruitData
end

-- Marketplace Receipt Processing
MarketplaceService.ProcessReceipt = function(receiptInfo)
	local player = Players:GetPlayerByUserId(receiptInfo.PlayerId)
	if not player then
		return Enum.ProductPurchaseDecision.NotProcessedYet
	end

	if receiptInfo.ProductId == 0 then
		local success, err = pcall(function()
			_G.WrappedPlayers[player].addBeli(10000)
		end)
		if success then
			print("Product purchased: Divine Sea")
		else
			_G.WrappedPlayers[player].notify("<Color=Red>Failed to send Reward<Color=/>")
		end
	end

	return Enum.ProductPurchaseDecision.PurchaseGranted
end

print("Server script loaded successfully!")
